<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>自定义注解详细介绍 | Vagrantの日常笔记</title><meta name="keywords" content="Java"><meta name="author" content="Vic Vagrant"><meta name="copyright" content="Vic Vagrant"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1 注解的概念1.1 注解的官方定义首先看看官方对注解的描述：  An annotation is a form of metadata, that can be added to Java source code. Classes, methods, variables, parameters and packages may be annotated. Annotations have no">
<meta property="og:type" content="article">
<meta property="og:title" content="自定义注解详细介绍">
<meta property="og:url" content="https://vagrantpoet.site/2020/06/23/Java/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/index.html">
<meta property="og:site_name" content="Vagrantの日常笔记">
<meta property="og:description" content="1 注解的概念1.1 注解的官方定义首先看看官方对注解的描述：  An annotation is a form of metadata, that can be added to Java source code. Classes, methods, variables, parameters and packages may be annotated. Annotations have no">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png">
<meta property="article:published_time" content="2020-06-23T01:45:03.000Z">
<meta property="article:modified_time" content="2020-06-23T01:45:03.000Z">
<meta property="article:author" content="Vic Vagrant">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://vagrantpoet.site/2020/06/23/Java/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Vic Vagrant","link":"链接: ","source":"来源: Vagrantの日常笔记","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '自定义注解详细介绍',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-06-23 09:45:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/LVicBlack/IMG/root/20210907231006.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Vagrantの日常笔记</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">自定义注解详细介绍</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-06-23T01:45:03.000Z" title="发表于 2020-06-23 09:45:03">2020-06-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-06-23T01:45:03.000Z" title="更新于 2020-06-23 09:45:03">2020-06-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="自定义注解详细介绍"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-注解的概念"><a href="#1-注解的概念" class="headerlink" title="1 注解的概念"></a>1 注解的概念</h2><h3 id="1-1-注解的官方定义"><a href="#1-1-注解的官方定义" class="headerlink" title="1.1 注解的官方定义"></a>1.1 注解的官方定义</h3><p>首先看看官方对注解的描述：</p>
<blockquote>
<p>An annotation is a form of metadata, that can be added to Java source code. Classes, methods, variables, parameters and packages may be annotated. Annotations have no direct effect on the operation of the code they annotate.</p>
</blockquote>
<p>翻译：</p>
<blockquote>
<p>注解是一种能被添加到java代码中的元数据，类、方法、变量、参数和包都可以用注解来修饰。注解对于它所修饰的代码并没有直接的影响。</p>
</blockquote>
<p>通过官方描述得出以下结论：</p>
<p>注解是一种元数据形式。即注解是属于java的一种数据类型，和类、接口、数组、枚举类似。</p>
<p>注解用来修饰，<span style="background-color: #ffaaaa">类、方法、变量、参数、包</span>。</p>
<p>注解<span style="background-color: #ffaaaa">不会对所修饰的代码产生直接的影响。</span></p>
<h3 id="1-2-注解的使用范围"><a href="#1-2-注解的使用范围" class="headerlink" title="1.2 注解的使用范围"></a>1.2 注解的使用范围</h3><p>继续看看官方对它的使用范围的描述：</p>
<blockquote>
<p>Annotations have a number of uses, among them:Information for the complier - Annotations can be used by the compiler to detect errors or suppress warnings.Compiler-time and deployment-time processing - Software tools can process annotation information to generate code, XML files, and so forth.Runtime processing - Some annotations are available to be examined at runtime.</p>
</blockquote>
<p>翻译：</p>
<blockquote>
<p>注解又许多用法，其中有：<span style="background-color: #ffaaaa">为编译器提供信息</span> - 注解能被编译器检测到错误或抑制警告。<span style="background-color: #ffaaaa">编译时和部署时的处理</span> - 软件工具能处理注解信息从而生成代码，XML文件等等。<span style="background-color: #ffaaaa">运行时的处理</span> - 有些注解在运行时能被检测到。</p>
</blockquote>
<h2 id="2-如何自定义注解"><a href="#2-如何自定义注解" class="headerlink" title="2 如何自定义注解"></a>2 如何自定义注解</h2><p>基于上一节，已对注解有了一个基本的认识：注解其实就是一种标记，可以在程序代码中的关键节点（类、方法、变量、参数、包）上打上这些标记，然后程序在编译时或运行时可以检测到这些标记从而执行一些特殊操作。因此可以得出自定义注解使用的基本流程：</p>
<p>第一步，定义注解——相当于定义标记；</p>
<p>第二步，配置注解——把标记打在需要用到的程序代码中；</p>
<p>第三步，解析注解——在编译期或运行时检测到标记，并进行特殊操作。<br><img src="https://cdn.jsdelivr.net/gh/LVicBlack/IMG/root/70.png" alt="70.png"></p>
<h3 id="2-1-基本语法"><a href="#2-1-基本语法" class="headerlink" title="2.1 基本语法"></a>2.1 基本语法</h3><p>注解类型的声明部分：</p>
<p>注解在Java中，与类、接口、枚举类似，因此其声明语法基本一致，只是所使用的关键字有所不同@interface。在底层实现上，所有定义的注解都会自动继承java.lang.annotation.Annotation接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public @interface CherryAnnotation &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解类型的实现部分：</p>
<p>根据我们在自定义类的经验，在类的实现部分无非就是书写构造、属性或方法。但是，在自定义注解中，其实现部分只能定义一个东西：注解类型元素（annotation type element）。咱们来看看其语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public @interface CherryAnnotation &#123;</span><br><span class="line">	public String name();</span><br><span class="line">	int age();</span><br><span class="line">	int[] array();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也许你会认为这不就是接口中定义抽象方法的语法嘛？别着急，咱们看看下面这个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public @interface CherryAnnotation &#123;</span><br><span class="line">	public String name();</span><br><span class="line">	int age() default 18;</span><br><span class="line">	int[] array();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到关键字default了吗？还觉得是抽象方法吗？</p>
<p>注解里面定义的是：注解类型元素！</p>
<p>定义注解类型元素时需要注意如下几点：</p>
<p><span style="background-color: #ffaaaa">访问修饰符必须为public，不写默认为public；</span></p>
<p>该元素的类型只能是<span style="background-color: #ffaaaa">基本数据类型、String、Class、枚举类型、注解类型</span>（体现了注解的嵌套效果）以及上述类型的一位<span style="background-color: #ffaaaa">数组</span>；</p>
<p>该元素的名称一般定义为名词，如果注解中<span style="background-color: #ffaaaa">只有一个元素</span>，请把名字起为<span style="background-color: #ffaaaa">value</span>（后面使用会带来便利操作）；</p>
<p>()不是定义方法参数的地方，也<span style="background-color: #ffaaaa">不能在括号中定义任何参数</span>，仅仅只是一个特殊的语法；</p>
<p><span style="background-color: #ffaaaa">default</span><span style="background-color: #ffaaaa">代表默认值，值必须和第2点定义的类型一致</span>；</p>
<p><span style="background-color: #ffaaaa">如果没有默认值，代表后续使用注解时必须给该类型元素赋值</span>。</p>
<p>可以看出，注解类型元素的语法非常奇怪，即又有属性的特征（可以赋值）,又有方法的特征（打上了一对括号）。但是这么设计是有道理的，我们在后面的章节中可以看到：注解在定义好了以后，使用的时候操作元素类型像在操作属性，解析的时候操作元素类型像在操作方法。</p>
<h3 id="2-2-常用的元注解"><a href="#2-2-常用的元注解" class="headerlink" title="2.2 常用的元注解"></a>2.2 常用的元注解</h3><p>一个最最基本的注解定义就只包括了上面的两部分内容：1、<span style="background-color: #ffaaaa">注解的名字</span>；2、<span style="background-color: #ffaaaa">注解包含的类型元素</span>。但是，我们在使用JDK自带注解的时候发现，有些注解只能写在方法上面（比如@Override）；有些却可以写在类的上面（比如@Deprecated）。当然除此以外还有很多细节性的定义，那么这些定义该如何做呢？接下来就该元注解出场了！</p>
<p>元注解：专门修饰注解的注解。它们都是为了更好的设计自定义注解的细节而专门设计的。我们为大家一个个来做介绍。</p>
<h4 id="2-2-1-Target"><a href="#2-2-1-Target" class="headerlink" title="2.2.1 @Target"></a>2.2.1 @Target</h4><p>@Target注解，是专门用来限定某个自定义注解能够被应用在哪些Java元素上面的。它使用一个枚举类型定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public enum ElementType &#123;</span><br><span class="line">    /** 类，接口（包括注解类型）或枚举的声明 */</span><br><span class="line">    TYPE,</span><br><span class="line"></span><br><span class="line">    /** 属性的声明 */</span><br><span class="line">    FIELD,</span><br><span class="line"></span><br><span class="line">    /** 方法的声明 */</span><br><span class="line">    METHOD,</span><br><span class="line"></span><br><span class="line">    /** 方法形式参数声明 */</span><br><span class="line">    PARAMETER,</span><br><span class="line"></span><br><span class="line">    /** 构造方法的声明 */</span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">    /** 局部变量声明 */</span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">    /** 注解类型声明 */</span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">    /** 包的声明 */</span><br><span class="line">    PACKAGE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//@CherryAnnotation被限定只能使用在类、接口或方法上面</span><br><span class="line">@Target(value = &#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line">public @interface CherryAnnotation &#123;</span><br><span class="line">    String name();</span><br><span class="line">    int age() default 18;</span><br><span class="line">    int[] array();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-2-Retention"><a href="#2-2-2-Retention" class="headerlink" title="2.2.2 @Retention"></a>2.2.2 @Retention</h4><p>@Retention注解，翻译为持久力、保持力。即用来修饰自定义注解的生命力。</p>
<p>注解的生命周期有三个阶段：1、Java源文件阶段；2、编译到class文件阶段；3、运行期阶段。同样使用了RetentionPolicy枚举类型定义了三个阶段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public enum RetentionPolicy &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Annotations are to be discarded by the compiler.</span><br><span class="line">     * （注解将被编译器忽略掉）</span><br><span class="line">     */</span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Annotations are to be recorded in the class file by the compiler</span><br><span class="line">     * but need not be retained by the VM at run time.  This is the default</span><br><span class="line">     * behavior.</span><br><span class="line">     * （注解将被编译器记录在class文件中，但在运行时不会被虚拟机保留，这是一个默认的行为）</span><br><span class="line">     */</span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Annotations are to be recorded in the class file by the compiler and</span><br><span class="line">     * retained by the VM at run time, so they may be read reflectively.</span><br><span class="line">     * （注解将被编译器记录在class文件中，而且在运行时会被虚拟机保留，因此它们能通过反射被读取到）</span><br><span class="line">     * @see java.lang.reflect.AnnotatedElement</span><br><span class="line">     */</span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再详解一下：</p>
<p>如果一个注解被定义为RetentionPolicy.SOURCE，则它将被限定在Java源文件中，那么这个注解即不会参与编译也不会在运行期起任何作用，这个注解就和一个注释是一样的效果，只能被阅读Java文件的人看到；</p>
<p>如果一个注解被定义为RetentionPolicy.CLASS，则它将被编译到Class文件中，那么编译器可以在编译时根据注解做一些处理动作，但是运行时JVM（Java虚拟机）会忽略它，我们在运行期也不能读取到；</p>
<p>如果一个注解被定义为RetentionPolicy.RUNTIME，那么这个注解可以在运行期的加载阶段被加载到Class对象中。那么在程序运行阶段，我们可以通过反射得到这个注解，并通过判断是否有这个注解或这个注解中属性的值，从而执行不同的程序代码段。我们实际开发中的自定义注解几乎都是使用的RetentionPolicy.RUNTIME；</p>
<p>在默认的情况下，自定义注解是使用的RetentionPolicy.CLASS。</p>
<h4 id="2-2-3-Documented"><a href="#2-2-3-Documented" class="headerlink" title="2.2.3 @Documented"></a>2.2.3 @Documented</h4><p>@Documented注解，是被用来指定自定义注解是否能随着被定义的java文件生成到JavaDoc文档当中。</p>
<h4 id="2-2-4-Inherited"><a href="#2-2-4-Inherited" class="headerlink" title="2.2.4 @Inherited"></a>2.2.4 @Inherited</h4><p>@Inherited注解，是指定某个自定义注解如果写在了父类的声明部分，那么子类的声明部分也能自动拥有该注解。@Inherited注解只对那些@Target被定义为ElementType.TYPE的自定义注解起作用。</p>
<h2 id="3-自定义注解的配置使用"><a href="#3-自定义注解的配置使用" class="headerlink" title="3 自定义注解的配置使用"></a>3 自定义注解的配置使用</h2><p>回顾一下注解的使用流程：</p>
<p>第一步，定义注解——相当于定义标记；</p>
<p>第二步，配置注解——把标记打在需要用到的程序代码中；</p>
<p>第三步，解析注解——在编译期或运行时检测到标记，并进行特殊操作。</p>
<p>到目前为止我们只是完成了第一步，接下来我们就来学习第二步，配置注解，如何在另一个类当中配置它。</p>
<h3 id="3-1-在具体的Java类上使用注解"><a href="#3-1-在具体的Java类上使用注解" class="headerlink" title="3.1 在具体的Java类上使用注解"></a>3.1 在具体的Java类上使用注解</h3><p>首先，定义一个注解、和一个供注解修饰的简单Java类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(value = &#123;ElementType.METHOD&#125;)</span><br><span class="line">@Documented</span><br><span class="line">public @interface CherryAnnotation &#123;</span><br><span class="line">    String name();</span><br><span class="line">    int age() default 18;</span><br><span class="line">    int[] score();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Student&#123;</span><br><span class="line">    public void study(int times)&#123;</span><br><span class="line">        for(int i = 0; i &lt; times; i++)&#123;</span><br><span class="line">            System.out.println(&quot;Good Good Study, Day Day Up!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单分析下：</p>
<p>CherryAnnotation的@Target定义为ElementType.METHOD，那么它书写的位置应该在方法定义的上方，即：public void study(int times)之上；</p>
<p>由于我们在CherryAnnotation中定义的有注解类型元素，而且有些元素是没有默认值的，这要求我们在使用的时候必须在标记名后面打上()，并且在()内以“元素名=元素值“的形式挨个填上所有没有默认值的注解类型元素（有默认值的也可以填上重新赋值），中间用“,”号分割；</p>
<p>所以最终书写形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">    @CherryAnnotation(name = &quot;cherry-peng&quot;,age = 23,score = &#123;99,66,77&#125;)</span><br><span class="line">    public void study(int times)&#123;</span><br><span class="line">        for(int i = 0; i &lt; times; i++)&#123;</span><br><span class="line">            System.out.println(&quot;Good Good Study, Day Day Up!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-2-特殊语法"><a href="#3-2-特殊语法" class="headerlink" title="3.2 特殊语法"></a>3.2 特殊语法</h3><p>特殊语法一：</p>
<p>如果注解本身没有注解类型元素，那么在使用注解的时候可以省略()，直接写为：@注解名，它和标准语法@注解名()等效！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(value = &#123;ElementType.TYPE&#125;)</span><br><span class="line">@Documented</span><br><span class="line">public @interface FirstAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//等效于@FirstAnnotation()</span><br><span class="line">@FirstAnnotation</span><br><span class="line">public class JavaBean&#123;</span><br><span class="line">	//省略实现部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特殊语法二：</p>
<p>如果注解本本身只有一个注解类型元素，而且命名为value，那么在使用注解的时候可以直接使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(value = &#123;ElementType.TYPE&#125;)</span><br><span class="line">@Documented</span><br><span class="line">public @interface SecondAnnotation &#123;</span><br><span class="line">	String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//等效于@ SecondAnnotation(value = &quot;this is second annotation&quot;)</span><br><span class="line">@SecondAnnotation(&quot;this is annotation&quot;)</span><br><span class="line">public class JavaBean&#123;</span><br><span class="line">	//省略实现部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特殊用法三：</p>
<p>如果注解中的某个注解类型元素是一个数组类型，在使用时又出现只需要填入一个值的情况，那么在使用注解时可以直接写为：@注解名(类型名 = 类型值)，它和标准写法：@注解名(类型名 = {类型值})等效！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(value = &#123;ElementType.TYPE&#125;)</span><br><span class="line">@Documented</span><br><span class="line">public @interface ThirdAnnotation &#123;</span><br><span class="line">	String[] name();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//等效于@ ThirdAnnotation(name = &#123;&quot;this is third annotation&quot;&#125;)</span><br><span class="line">@ ThirdAnnotation(name = &quot;this is third annotation&quot;)</span><br><span class="line">public class JavaBean&#123;</span><br><span class="line">	//省略实现部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特殊用法四：</p>
<p>如果一个注解的@Target是定义为Element.PACKAGE，那么这个注解是配置在package-info.java中的，而不能直接在某个类的package代码上面配置。</p>
<h2 id="4-自定义注解的运行时解析"><a href="#4-自定义注解的运行时解析" class="headerlink" title="4 自定义注解的运行时解析"></a>4 自定义注解的运行时解析</h2><p>这一章是使用注解的核心，读完此章即可明白，如何在程序运行时检测到注解，并进行一系列特殊操作！</p>
<h3 id="4-1-回顾注解的保持力"><a href="#4-1-回顾注解的保持力" class="headerlink" title="4.1 回顾注解的保持力"></a>4.1 回顾注解的保持力</h3><p>首先回顾一下，之前自定义的注解@CherryAnnotation，并把它配置在了类Student上，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(value = &#123;ElementType.METHOD&#125;)</span><br><span class="line">@Documented</span><br><span class="line">public @interface CherryAnnotation &#123;</span><br><span class="line">    String name();</span><br><span class="line">    int age() default 18;</span><br><span class="line">    int[] score();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package pojos;</span><br><span class="line">public class Student &#123;</span><br><span class="line">    @CherryAnnotation(name = &quot;cherry-peng&quot;,age = 23,score = &#123;99,66,77&#125;)</span><br><span class="line">    public void study(int times)&#123;</span><br><span class="line">        for(int i = 0; i &lt; times; i++)&#123;</span><br><span class="line">            System.out.println(&quot;Good Good Study, Day Day Up!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解保持力的三个阶段：</p>
<p>Java源文件阶段；</p>
<p>编译到class文件阶段；</p>
<p>运行期阶段。</p>
<p>只有当注解的保持力处于运行阶段，即使用@Retention(RetentionPolicy.RUNTIME)修饰注解时，才能在JVM运行时，检测到注解，并进行一系列特殊操作。</p>
<h3 id="4-2-反射操作获取注解"><a href="#4-2-反射操作获取注解" class="headerlink" title="4.2 反射操作获取注解"></a>4.2 反射操作获取注解</h3><p>因此，明确我们的目标：在运行期探究和使用编译期的内容（编译期配置的注解），要用到Java中的灵魂技术——反射！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class TestAnnotation &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //获取Student的Class对象</span><br><span class="line">            Class stuClass = Class.forName(&quot;pojos.Student&quot;);</span><br><span class="line"></span><br><span class="line">            //说明一下，这里形参不能写成Integer.class，应写为int.class</span><br><span class="line">            Method stuMethod = stuClass.getMethod(&quot;study&quot;,int.class);</span><br><span class="line"></span><br><span class="line">            if(stuMethod.isAnnotationPresent(CherryAnnotation.class))&#123;</span><br><span class="line">                System.out.println(&quot;Student类上配置了CherryAnnotation注解！&quot;);</span><br><span class="line">                //获取该元素上指定类型的注解</span><br><span class="line">                CherryAnnotation cherryAnnotation = stuMethod.getAnnotation(CherryAnnotation.class);</span><br><span class="line">                System.out.println(&quot;name: &quot; + cherryAnnotation.name() + &quot;, age: &quot; + cherryAnnotation.age()</span><br><span class="line">                    + &quot;, score: &quot; + cherryAnnotation.score()[0]);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                System.out.println(&quot;Student类上没有配置CherryAnnotation注解！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释一下：</p>
<p>如果我们要获得的注解是配置在方法上的，那么我们要从Method对象上获取；如果是配置在属性上，就需要从该属性对应的Field对象上去获取，如果是配置在类型上，需要从Class对象上去获取。总之在谁身上，就从谁身上去获取！</p>
<p><code>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</code>方法是专门判断该元素上是否配置有某个指定的注解；</p>
<p><code>getAnnotation(Class&lt;A&gt; annotationClass)</code>方法是获取该元素上指定的注解。之后再调用该注解的注解类型元素方法就可以获得配置时的值数据；</p>
<p>反射对象上还有一个方法getAnnotations()，该方法可以获得该对象身上配置的所有的注解。它会返回给我们一个注解数组，需要注意的是该数组的类型是Annotation类型，这个Annotation是一个来自于java.lang.annotation包的接口。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Vic Vagrant</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://vagrantpoet.site/2020/06/23/Java/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/">https://vagrantpoet.site/2020/06/23/Java/自定义注解详细介绍/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://vagrantpoet.site" target="_blank">Vagrantの日常笔记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/06/23/Java/getDeclaredField%E5%92%8CgetField%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB,%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E7%88%B6%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%AD%97%E6%AE%B5/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">getDeclaredField和getField的使用和区别,以及如何获取父类的私有字段</div></div></a></div><div class="next-post pull-right"><a href="/2020/07/26/Java/CGLIB%E5%92%8CJava%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CGLIB和Java动态代理的区别</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/05/20/Java/ABA问题产生及解决方案/" title="ABA问题产生及解决方案"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-09-12</div><div class="title">ABA问题产生及解决方案</div></div></a></div><div><a href="/2020/07/26/Java/CGLIB和Java动态代理的区别/" title="CGLIB和Java动态代理的区别"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-09-12</div><div class="title">CGLIB和Java动态代理的区别</div></div></a></div><div><a href="/2020/03/17/Java/GC算法之三_标记-压缩算法/" title="GC算法之 标记-压缩算法"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-09-12</div><div class="title">GC算法之 标记-压缩算法</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/LVicBlack/IMG/root/20210907231006.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Vic Vagrant</div><div class="author-info__description">醒醒</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">印象笔记搬运中。。。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">1 注解的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%98%E6%96%B9%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 注解的官方定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 注解的使用范围</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">2 如何自定义注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 常用的元注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-Target"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1 @Target</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-Retention"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2 @Retention</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-Documented"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.2.3 @Documented</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-Inherited"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.2.4 @Inherited</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">3 自定义注解的配置使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%9C%A8%E5%85%B7%E4%BD%93%E7%9A%84Java%E7%B1%BB%E4%B8%8A%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 在具体的Java类上使用注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%89%B9%E6%AE%8A%E8%AF%AD%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 特殊语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E8%A7%A3%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">4 自定义注解的运行时解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%9B%9E%E9%A1%BE%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BF%9D%E6%8C%81%E5%8A%9B"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 回顾注解的保持力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%8F%8D%E5%B0%84%E6%93%8D%E4%BD%9C%E8%8E%B7%E5%8F%96%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 反射操作获取注解</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/09/03/Java/hexo-%E5%90%8C%E6%AD%A5%E7%AE%A1%E7%90%86%E5%92%8C%E8%BF%81%E7%A7%BB/" title="hexo 同步管理和迁移"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hexo 同步管理和迁移"/></a><div class="content"><a class="title" href="/2021/09/03/Java/hexo-%E5%90%8C%E6%AD%A5%E7%AE%A1%E7%90%86%E5%92%8C%E8%BF%81%E7%A7%BB/" title="hexo 同步管理和迁移">hexo 同步管理和迁移</a><time datetime="2021-09-03T01:49:30.000Z" title="发表于 2021-09-03 09:49:30">2021-09-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/31/Java/hexo-%E6%90%AD%E5%BB%BA/" title="hexo 搭建"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hexo 搭建"/></a><div class="content"><a class="title" href="/2021/08/31/Java/hexo-%E6%90%AD%E5%BB%BA/" title="hexo 搭建">hexo 搭建</a><time datetime="2021-08-31T15:31:21.000Z" title="发表于 2021-08-31 23:31:21">2021-08-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/14/Java/volatile%E5%85%B3%E9%94%AE%E5%AD%97/" title="volatile关键字"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="volatile关键字"/></a><div class="content"><a class="title" href="/2021/05/14/Java/volatile%E5%85%B3%E9%94%AE%E5%AD%97/" title="volatile关键字">volatile关键字</a><time datetime="2021-05-13T22:17:03.000Z" title="发表于 2021-05-14 06:17:03">2021-05-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/08/Java/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/" title="synchronized锁升级过程"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="synchronized锁升级过程"/></a><div class="content"><a class="title" href="/2021/03/08/Java/synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B/" title="synchronized锁升级过程">synchronized锁升级过程</a><time datetime="2021-03-08T04:17:03.000Z" title="发表于 2021-03-08 12:17:03">2021-03-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/08/Java/%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB/" title="并行和并发的区别"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="并行和并发的区别"/></a><div class="content"><a class="title" href="/2021/03/08/Java/%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB/" title="并行和并发的区别">并行和并发的区别</a><time datetime="2021-03-07T22:17:03.000Z" title="发表于 2021-03-08 06:17:03">2021-03-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Vic Vagrant</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>