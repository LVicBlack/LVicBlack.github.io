<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>动态代理、CGlib、AOP | Vagrantの日常笔记</title><meta name="keywords" content="Java,面试"><meta name="author" content="Vic Vagrant"><meta name="copyright" content="Vic Vagrant"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java 代理模式实现方式，主要有如下五种方法 静态代理，工程师编辑代理类代码，实现代理模式；在编译期就生成了代理类。 基于 JDK 实现动态代理，通过jdk提供的工具方法Proxy.newProxyInstance动态构建全新的代理类(继承Proxy类，并持有InvocationHandler接口引用 )字节码文件并实例化对象返回。(jdk动态代理是由java内部的反射机制来实例化代理对象，并代">
<meta property="og:type" content="article">
<meta property="og:title" content="动态代理、CGlib、AOP">
<meta property="og:url" content="https://vagrantpoet.site/2020/07/27/Java/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E3%80%81CGlib%E3%80%81AOP/index.html">
<meta property="og:site_name" content="Vagrantの日常笔记">
<meta property="og:description" content="Java 代理模式实现方式，主要有如下五种方法 静态代理，工程师编辑代理类代码，实现代理模式；在编译期就生成了代理类。 基于 JDK 实现动态代理，通过jdk提供的工具方法Proxy.newProxyInstance动态构建全新的代理类(继承Proxy类，并持有InvocationHandler接口引用 )字节码文件并实例化对象返回。(jdk动态代理是由java内部的反射机制来实例化代理对象，并代">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png">
<meta property="article:published_time" content="2020-07-27T03:42:03.000Z">
<meta property="article:modified_time" content="2020-07-27T03:42:03.000Z">
<meta property="article:author" content="Vic Vagrant">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://vagrantpoet.site/2020/07/27/Java/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E3%80%81CGlib%E3%80%81AOP/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Vic Vagrant","link":"链接: ","source":"来源: Vagrantの日常笔记","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '动态代理、CGlib、AOP',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-07-27 11:42:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/LVicBlack/IMG/root/20210907231006.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">76</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">27</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Vagrantの日常笔记</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">动态代理、CGlib、AOP</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-27T03:42:03.000Z" title="发表于 2020-07-27 11:42:03">2020-07-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-07-27T03:42:03.000Z" title="更新于 2020-07-27 11:42:03">2020-07-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>41分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="动态代理、CGlib、AOP"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Java-代理模式实现方式，主要有如下五种方法"><a href="#Java-代理模式实现方式，主要有如下五种方法" class="headerlink" title="Java 代理模式实现方式，主要有如下五种方法"></a>Java 代理模式实现方式，主要有如下五种方法</h2><ul>
<li>静态代理，工程师编辑代理类代码，实现代理模式；在编译期就生成了代理类。</li>
<li>基于 JDK 实现动态代理，通过jdk提供的工具方法Proxy.newProxyInstance动态构建全新的代理类(继承Proxy类，并持有InvocationHandler接口引用 )字节码文件并实例化对象返回。(jdk动态代理是由java内部的反射机制来实例化代理对象，并代理的调用委托类方法)</li>
<li>基于CGlib 动态代理模式 基于继承被代理类生成代理子类，不用实现接口。只需要被代理类是非final 类即可。(cglib动态代理底层是借助asm字节码技术</li>
<li>基于 Aspectj 实现动态代理（修改目标类的字节，织入代理的字节，在程序编译的时候 插入动态代理的字节码，不会生成全新的Class ）</li>
<li>基于 instrumentation 实现动态代理（修改目标类的字节码、类装载的时候动态拦截去修改，基于javaagent） <code>-javaagent:spring-instrument-4.3.8.RELEASE.jar</code> （类装载的时候 插入动态代理的字节码，不会生成全新的Class ）</li>
</ul>
<h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2><ul>
<li>委托类 即指的是代理模式中的被代理对象</li>
<li>代理类 指的是生成的代表委托类的一个角色</li>
</ul>
<h2 id="静态代理实现"><a href="#静态代理实现" class="headerlink" title="静态代理实现"></a>静态代理实现</h2><p>静态代理是代理类在编译期间就创建好了，不是编译器生成的代理类，而是手动创建的类。在编译时就已经将接口，被代理类，代理类等确定下来。，软件设计中所指的代理一般是指静态代理，也就是在代码中显式指定的代理。</p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ul>
<li>委托类和代理类之间的约束接口Cat</li>
<li>约束接口实现类 Lion，实现 Cat 接口，委托角色</li>
<li>代理类实现 FeederProxy，实现Cat 接口，并含有一个 Cat接口引用属性。 代理角色，代理 cat接口属性引用实例的行为并可以新增公共逻辑</li>
</ul>
<h4 id="Cat接口"><a href="#Cat接口" class="headerlink" title="Cat接口"></a>Cat接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package org.vincent.proxy.staticproxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author PengRong</span><br><span class="line"> * @package org.vincent.proxy.staticproxy</span><br><span class="line"> * @date 2018/12/15 - 17:12</span><br><span class="line"> * @ProjectName JavaAopLearning</span><br><span class="line"> * @Description: 静态代理类接口, 委托类和代理类都需要实现的接口规范。</span><br><span class="line"> * 定义了一个猫科动物的两个行为接口，吃东西，奔跑。</span><br><span class="line"> * 作为代理类 和委托类之间的约束接口</span><br><span class="line"> */</span><br><span class="line">public interface Cat &#123;</span><br><span class="line">    public String eatFood(String foodName);</span><br><span class="line"></span><br><span class="line">    public boolean running();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="委托类-Lion"><a href="#委托类-Lion" class="headerlink" title="委托类 Lion"></a>委托类 Lion</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package org.vincent.proxy.staticproxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author PengRong</span><br><span class="line"> * @package org.vincent.proxy.staticproxy</span><br><span class="line"> * @date 2018/12/15 - 17:15</span><br><span class="line"> * @ProjectName JavaAopLearning</span><br><span class="line"> * @Description: 狮子 实现了猫科动物接口Cat， 并实现了具体的行为。作为委托类实现</span><br><span class="line"> */</span><br><span class="line">public class Lion implements Cat &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int runningSpeed;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getRunningSpeed() &#123;</span><br><span class="line">        return runningSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRunningSpeed(int runningSpeed) &#123;</span><br><span class="line">        this.runningSpeed = runningSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Lion() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String eatFood(String foodName) &#123;</span><br><span class="line">        String eat = this.name + &quot; Lion eat food. foodName = &quot; + foodName;</span><br><span class="line">        System.out.println(eat);</span><br><span class="line">        return eat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean running() &#123;</span><br><span class="line">        System.out.println(this.name + &quot; Lion is running . Speed :&quot; + this.runningSpeed);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="代理类角色-FeederProxy"><a href="#代理类角色-FeederProxy" class="headerlink" title="代理类角色(FeederProxy)"></a>代理类角色(FeederProxy)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package org.vincent.proxy.staticproxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author PengRong</span><br><span class="line"> * @package org.vincent.proxy.staticproxy</span><br><span class="line"> * @date 2018/12/15 - 17:19</span><br><span class="line"> * @ProjectName JavaAopLearning</span><br><span class="line"> * @Description: 饲养员 实现Cat接口，作为静态代理类实现。代理狮子的行为。</span><br><span class="line"> * 代理类中可以新增一些其他行为，在实践中主要做的是参数校验的功能。</span><br><span class="line"> */</span><br><span class="line">public class FeederProxy implements Cat &#123;</span><br><span class="line">    private Cat cat;</span><br><span class="line"></span><br><span class="line">    public FeederProxy() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public FeederProxy(Cat cat) &#123;</span><br><span class="line">        if (cat instanceof Cat) &#123;</span><br><span class="line">            this.cat = cat;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCat(Cat cat) &#123;</span><br><span class="line">        if (cat instanceof Cat) &#123;</span><br><span class="line">            this.cat = cat;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String eatFood(String foodName) &#123;</span><br><span class="line">        System.out.println(&quot;proxy Lion exec eatFood &quot;);</span><br><span class="line">        return cat.eatFood(foodName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean running() &#123;</span><br><span class="line">        System.out.println(&quot;proxy Lion exec running.&quot;);</span><br><span class="line">        return cat.running();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="静态代理类测试"><a href="#静态代理类测试" class="headerlink" title="静态代理类测试"></a>静态代理类测试</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package org.vincent.proxy;</span><br><span class="line">import org.vincent.proxy.staticproxy.Cat;</span><br><span class="line">import org.vincent.proxy.staticproxy.FeederProxy;</span><br><span class="line">import org.vincent.proxy.staticproxy.Lion;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author PengRong</span><br><span class="line"> * @package org.vincent.proxy</span><br><span class="line"> * @date 2018/12/15 - 18:31</span><br><span class="line"> * @ProjectName JavaAopLearning</span><br><span class="line"> * @Description: 静态代理类测试</span><br><span class="line"> */</span><br><span class="line">public class staticProxyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Lion lion = new Lion();</span><br><span class="line">        lion.setName(&quot;狮子 小王&quot;);</span><br><span class="line">        lion.setRunningSpeed(100);        /**</span><br><span class="line">         * new 静态代理类，静态代理类在编译前已经创建好了，和动态代理的最大区别点</span><br><span class="line">         */</span><br><span class="line">        Cat proxy = new FeederProxy(lion);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot; -- &quot; + proxy.eatFood(&quot;水牛&quot;));</span><br><span class="line">        proxy.running();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态代理很好的诠释了代理设计模式，代理模式最主要的就是有一个公共接口（Cat），一个委托类（Lion），一个代理类（FeederProxy）,代理类持有委托类的实例，代为执行具体类实例方法。 上面说到，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。这里的间接性就是指客户端不直接调用实际对象的方法，客户端依赖公共接口并使用代理类。 那么我们在代理过程中就可以加上一些其他用途。 就这个例子来说在 eatFood方法调用中，代理类在调用具体实现类之前添加<code>System.out.println(&quot;proxy Lion exec eatFood &quot;);</code>语句 就是添加间接性带来的收益。代理类存在的意义是为了增加一些公共的逻辑代码。</p>
<h2 id="动态代理类-基于接口实现"><a href="#动态代理类-基于接口实现" class="headerlink" title="动态代理类(基于接口实现)"></a>动态代理类(基于接口实现)</h2><p>静态代理是代理类在代码运行前已经创建好，并生成class文件；动态代理类 是代理类在程序运行时创建的代理模式。</p>
<p>动态代理类的代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。 想想你有100个静态代理类，现在有一个需求，每个代理类都需要新增一个处理逻辑，你需要打开100个代理类在每个代理方法里面新增处理逻辑吗？ 有或者代理类有5个方法，每个方法都需要新增一个处理逻辑， 你需要在每个方法都手动新增处理逻辑吗？ 想想就挺无趣的。动态代理类帮你一键搞定。</p>
<h3 id="动态代理类涉及角色"><a href="#动态代理类涉及角色" class="headerlink" title="动态代理类涉及角色"></a>动态代理类涉及角色</h3><ul>
<li>委托类和代理类实现的公共接口(Person.java)</li>
<li>实现公共接口的具体委托类(SoftwareEngineer.java)</li>
<li>InvocationHandler接口被Proxy类回调处理，一般实现 InvocationHandler 接口的类具有委托类引用，接口方法 invoke 中添加公共代码并调用委托类的接口方法。(PersonInvocationHandler.java)</li>
<li>JDK提供生成动态代理类的核心类Proxy ( JDK 提供的Proxy.java)</li>
</ul>
<h3 id="基于JDK技术-动态代理类技术核心-Proxy类和一个-InvocationHandler-接口"><a href="#基于JDK技术-动态代理类技术核心-Proxy类和一个-InvocationHandler-接口" class="headerlink" title="基于JDK技术 动态代理类技术核心 Proxy类和一个 InvocationHandler 接口"></a>基于JDK技术 动态代理类技术核心 Proxy类和一个 InvocationHandler 接口</h3><p>java的java.lang.reflect包下提供了Proxy类和一个 InvocationHandler 接口，这个类Proxy定义了生成JDK动态代理类的方法 <code>getProxyClass(ClassLoader loader,Class&lt;?&gt;... interfaces)</code>生成动态代理类,返回class实例代表一个class文件。可以保存该 class 文件查看jdk生成的代理类文件长什么样</p>
<p>该生成的动态代理类继承Proxy类，(重要特性) ，并实现公共接口。</p>
<p>InvocationHandler这个接口 是被动态代理类回调的接口，我们所有需要增加的针对委托类的统一处理逻辑都增加到invoke 方法里面在调用委托类接口方法之前或之后 结束战斗。</p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><h5 id="公共接口"><a href="#公共接口" class="headerlink" title="公共接口"></a>公共接口</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package org.vincent.proxy.dynamicproxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by PengRong on 2018/12/25.</span><br><span class="line"> * 创建Person 接口 用于定义 委托类和代理类之间的约束行为</span><br><span class="line"> */</span><br><span class="line">public interface Person &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param name 人名</span><br><span class="line">     * @param dst  工作目的地</span><br><span class="line">     */</span><br><span class="line">    void goWorking(String name, String dst);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取名称</span><br><span class="line">     *</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    String getName();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置名称</span><br><span class="line">     *</span><br><span class="line">     * @param name</span><br><span class="line">     */</span><br><span class="line">    void setName(String name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="具体实现类，等下被委托，被代理的类-SoftwareEngineer-java"><a href="#具体实现类，等下被委托，被代理的类-SoftwareEngineer-java" class="headerlink" title="具体实现类，等下被委托，被代理的类 SoftwareEngineer.java"></a>具体实现类，等下被委托，被代理的类 SoftwareEngineer.java</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package org.vincent.proxy.dynamicproxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by PengRong on 2018/12/25.</span><br><span class="line"> * 动态代理委托类实现， 实现接口 Person。 被动态生成的代理类代理</span><br><span class="line"> */</span><br><span class="line">public class SoftwareEngineer implements Person &#123;</span><br><span class="line">    public SoftwareEngineer() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SoftwareEngineer(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void goWorking(String name, String dst) &#123;</span><br><span class="line">        System.out.println(&quot;name =&quot; + name + &quot; ， 去 &quot; + dst + &quot; 工作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="InvocationHandler-接口实现-PersonInvocationHandler-java"><a href="#InvocationHandler-接口实现-PersonInvocationHandler-java" class="headerlink" title="InvocationHandler 接口实现 PersonInvocationHandler.java"></a>InvocationHandler 接口实现 PersonInvocationHandler.java</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package org.vincent.proxy.dynamicproxy;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by PengRong on 2018/12/25.</span><br><span class="line"> * PersonInvocationHandler 类 实现InvocationHandler接口，这个类中持有一个被代理对象(委托类)的实例target。该类别JDK Proxy类回调</span><br><span class="line"> * InvocationHandler 接口中有一个invoke方法，当一个代理实例的方法被调用时，代理方法将被编码并分发到 InvocationHandler接口的invoke方法执行。</span><br><span class="line"> */</span><br><span class="line">public class PersonInvocationHandler&lt;T&gt; implements InvocationHandler &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 被代理对象引用，invoke 方法里面method 需要使用这个 被代理对象</span><br><span class="line">     */</span><br><span class="line">    T target;</span><br><span class="line"></span><br><span class="line">    public PersonInvocationHandler(T target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 在</span><br><span class="line">     *</span><br><span class="line">     * @param proxy  代表动态生成的 动态代理 对象实例</span><br><span class="line">     * @param method 代表被调用委托类的接口方法，和生成的代理类实例调用的接口方法是一致的，它对应的Method 实例</span><br><span class="line">     * @param args   代表调用接口方法对应的Object参数数组，如果接口是无参，则为null； 对于原始数据类型返回的他的包装类型。</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Throwable</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        /**</span><br><span class="line">     * 在转调具体目标对象之前，可以执行一些功能处理</span><br><span class="line">     */</span><br><span class="line">        System.out.println(&quot;被动态代理类回调执行, 代理类 proxyClass =&quot; + proxy.getClass() + &quot; 方法名: &quot; + method.getName() + &quot;方法. 方法返回类型：&quot; + method.getReturnType()</span><br><span class="line">                + &quot; 接口方法入参数组: &quot; + (args == null ? &quot;null&quot; : Arrays.toString(args)));        /**</span><br><span class="line">         * 代理过程中插入监测方法,计算该方法耗时</span><br><span class="line">         */</span><br><span class="line">        MonitorUtil.start();</span><br><span class="line">        Thread.sleep(1);        /** 调用呗代理对象的真实方法，*/</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        MonitorUtil.finish(method.getName());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="PersonInvocationHandler-invoke-方法中添加的公共代码，这里简单以统计方法执行时间为逻辑"><a href="#PersonInvocationHandler-invoke-方法中添加的公共代码，这里简单以统计方法执行时间为逻辑" class="headerlink" title="PersonInvocationHandler invoke 方法中添加的公共代码，这里简单以统计方法执行时间为逻辑"></a>PersonInvocationHandler invoke 方法中添加的公共代码，这里简单以统计方法执行时间为逻辑</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package org.vincent.proxy.dynamicproxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by PengRong on 2018/12/25.</span><br><span class="line"> * 方法用时监控类</span><br><span class="line"> */</span><br><span class="line">public class MonitorUtil &#123;</span><br><span class="line">    private static ThreadLocal&lt;Long&gt; tl = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void start() &#123;</span><br><span class="line">        tl.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 结束时打印耗时</span><br><span class="line">     *</span><br><span class="line">     * @param methodName 方法名</span><br><span class="line">     */</span><br><span class="line">    public static void finish(String methodName) &#123;</span><br><span class="line">        long finishTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(methodName + &quot;方法执行耗时&quot; + (finishTime - tl.get()) + &quot;ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="最后的是-怎么创建代理类"><a href="#最后的是-怎么创建代理类" class="headerlink" title="最后的是 怎么创建代理类"></a>最后的是 怎么创建代理类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">package org.vincent.proxy.jdkdynamicProxy;</span><br><span class="line">import org.vincent.proxy.dynamicproxy.Person;</span><br><span class="line">import org.vincent.proxy.dynamicproxy.PersonInvocationHandler;</span><br><span class="line">import org.vincent.proxy.dynamicproxy.SoftwareEngineer;</span><br><span class="line">import sun.misc.ProxyGenerator;</span><br><span class="line"></span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.nio.file.Path;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 动态代理类测试</span><br><span class="line"> * Created by PengRong on 2018/12/25.</span><br><span class="line"> */</span><br><span class="line">public class JdkDynamicProxyTest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;        // 打开保存JDK动态代理生成的类文件</span><br><span class="line">        saveGeneratedJdkProxyFiles();        /**</span><br><span class="line">         * 第一种方法: 通过 Proxy.newProxyInstance 方法 获取代理对象</span><br><span class="line">         */</span><br><span class="line">        System.out.println(&quot;-------------------第一种创建代理类方法--------------&quot;);        //创建一个实例对象，这个对象是被代理的对象，委托类</span><br><span class="line">        Person person = new SoftwareEngineer(&quot;Vincent&quot;);        //创建一个与代理类相关联的InvocationHandler,每一个代理类都有一个关联的 InvocationHandler，并将代理类引用传递进去</span><br><span class="line">        InvocationHandler Handler = new PersonInvocationHandler&lt;&gt;(person);        //创建一个 代理对象 personProxy 来代理 person，创建的代理对象的每个执行方法都会被替换执行Invocation接口中的invoke方法</span><br><span class="line">        Person personProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;, Handler);        /** 代理类信息 */</span><br><span class="line">        System.out.println(&quot;package = &quot; + personProxy.getClass().getPackage() + &quot; SimpleName = &quot; + personProxy.getClass().getSimpleName() + &quot; name =&quot; + personProxy.getClass().getName() + &quot; CanonicalName = &quot; + &quot;&quot; + personProxy.getClass().getCanonicalName() + &quot; 实现的接口 Interfaces = &quot; + Arrays.toString(personProxy.getClass().getInterfaces()) + &quot; superClass = &quot; + personProxy.getClass().getSuperclass() + &quot; methods =&quot; + Arrays.toString(personProxy.getClass().getMethods()));        // 通过 代理类 执行 委托类的代码逻辑</span><br><span class="line">        personProxy.goWorking(personProxy.getName(), &quot;深圳&quot;);</span><br><span class="line">        System.out.println(&quot;-------------------第二种创建代理类方法--------------&quot;);        /**</span><br><span class="line">         *  动态代理对象步骤</span><br><span class="line">         *      1、 创建一个与代理对象相关联的 InvocationHandler，以及真实的委托类实例</span><br><span class="line">         *      2、Proxy类的getProxyClass静态方法生成一个动态代理类stuProxyClass，该类继承Proxy类，实现 Person.java接口；JDK动态代理的特点是代理类必须继承Proxy类</span><br><span class="line">         *      3、通过代理类 proxyClass 获得他的带InvocationHandler 接口的构造函数 ProxyConstructor</span><br><span class="line">         *      4、通过 构造函数实例 ProxyConstructor 实例化一个代理对象，并将  InvocationHandler 接口实例传递给代理类。</span><br><span class="line">         */</span><br><span class="line">        // 1、创建 InvocationHandler 实例并设置代理的目标类对象</span><br><span class="line">        Person persontwo = new SoftwareEngineer(&quot;Vincent&quot;);</span><br><span class="line">        InvocationHandler Handlertwo = new PersonInvocationHandler&lt;&gt;(persontwo);        // 2 创建代理类,是一个字节码文件, 把 proxyClass 保存起来就能看到 他继承Proxy 类，实现Person接口</span><br><span class="line">        Class&lt;?&gt; proxyClass = Proxy.getProxyClass(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;);        /** 代理类信息 */</span><br><span class="line">        System.out.println(&quot;package = &quot; + proxyClass.getPackage() + &quot; SimpleName = &quot; + proxyClass.getSimpleName() + &quot; name =&quot; + proxyClass.getName() + &quot; CanonicalName = &quot; + &quot;&quot; + proxyClass.getCanonicalName() + &quot; 实现的接口 Interfaces = &quot; + Arrays.toString(proxyClass.getInterfaces()) + &quot; superClass = &quot; + proxyClass.getSuperclass() + &quot; methods =&quot; + Arrays.toString(proxyClass.getMethods()));        // 3、  通过 proxyClass 获得 一个带有InvocationHandler参数的构造器constructor</span><br><span class="line">        Constructor&lt;?&gt; ProxyConstructor = proxyClass.getConstructor(InvocationHandler.class);        // 4、通过构造器创建一个  动态代理类 实例</span><br><span class="line">        Person stuProxy = (Person) ProxyConstructor.newInstance(Handlertwo);        /** 检测生成的类是否是代理类 */</span><br><span class="line">        System.out.println(&quot;stuProxy isProxy &quot; + Proxy.isProxyClass(stuProxy.getClass()));        /** 获取 代理类关联的 InvocationHandler 是哪个*/</span><br><span class="line">        InvocationHandler handlerObject = Proxy.getInvocationHandler(stuProxy);</span><br><span class="line">        System.out.println(handlerObject.getClass().getName());</span><br><span class="line">        stuProxy.goWorking(stuProxy.getName(), &quot;广州&quot;);        // 保存代理類</span><br><span class="line">        saveClass(&quot;$PersonProxy0&quot;, proxyClass.getInterfaces(), &quot;D:/123/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成代理类 class 并保持到文件中</span><br><span class="line">     *</span><br><span class="line">     * @param className  生成的代理类名称</span><br><span class="line">     * @param interfaces 代理类需要实现的接口</span><br><span class="line">     * @param pathdir    代理类保存的目录路径,以目录分隔符结尾</span><br><span class="line">     */</span><br><span class="line">    public static void saveClass(String className, Class&lt;?&gt;[] interfaces, String pathdir) &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 第一个参数是 代理类 名 。</span><br><span class="line">         * 第二个参数是 代理类需要实现的接口</span><br><span class="line">         */</span><br><span class="line">        byte[] classFile = ProxyGenerator.generateProxyClass(className, interfaces);</span><br><span class="line">        /**</span><br><span class="line">         * 如果目录不存在就新建所有子目录</span><br><span class="line">         */</span><br><span class="line">        Path path1 = Paths.get(pathdir);</span><br><span class="line">        if (!path1.toFile().exists()) &#123;</span><br><span class="line">            path1.toFile().mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        String path = pathdir + className + &quot;.class&quot;;</span><br><span class="line">        try (FileOutputStream fos = new FileOutputStream(path)) &#123;</span><br><span class="line">            fos.write(classFile);</span><br><span class="line">            fos.flush();</span><br><span class="line">            System.out.println(&quot;代理类class文件写入成功&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;写文件错误&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置保存Java动态代理生成的类文件。</span><br><span class="line">     *</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public static void saveGeneratedJdkProxyFiles() throws Exception &#123;</span><br><span class="line">        Field field = System.class.getDeclaredField(&quot;props&quot;);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        Properties props = (Properties) field.get(null);</span><br><span class="line">        props.put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="解析JDK生成的动态代理类"><a href="#解析JDK生成的动态代理类" class="headerlink" title="解析JDK生成的动态代理类"></a>解析JDK生成的动态代理类</h4><p>saveGeneratedJdkProxyFiles方法 打开了存储jdk生成的动态代理类 以 接口方法 goWorking 为例讲解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package com.sun.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;import org.vincent.proxy.dynamicproxy.Person;public final class $Proxy0 extends Proxy implements Person &#123;    private static Method m1;    private static Method m4;    private static Method m3;    private static Method m2;    private static Method m5;    private static Method m0;    public $Proxy0(InvocationHandler var1) throws  &#123;        super(var1);</span><br><span class="line">   &#125;    public final boolean equals(Object var1) throws  &#123;        try &#123;            return ((Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;)).booleanValue();</span><br><span class="line">       &#125; catch (RuntimeException | Error var3) &#123;            throw var3;</span><br><span class="line">       &#125; catch (Throwable var4) &#123;            throw new UndeclaredThrowableException(var4);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    public final void setName(String var1) throws  &#123;        try &#123;            super.h.invoke(this, m4, new Object[]&#123;var1&#125;);</span><br><span class="line">       &#125; catch (RuntimeException | Error var3) &#123;            throw var3;</span><br><span class="line">       &#125; catch (Throwable var4) &#123;            throw new UndeclaredThrowableException(var4);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    public final String getName() throws  &#123;        try &#123;            return (String)super.h.invoke(this, m3, (Object[])null);</span><br><span class="line">       &#125; catch (RuntimeException | Error var2) &#123;            throw var2;</span><br><span class="line">       &#125; catch (Throwable var3) &#123;            throw new UndeclaredThrowableException(var3);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    public final String toString() throws  &#123;        try &#123;            return (String)super.h.invoke(this, m2, (Object[])null);</span><br><span class="line">       &#125; catch (RuntimeException | Error var2) &#123;            throw var2;</span><br><span class="line">       &#125; catch (Throwable var3) &#123;            throw new UndeclaredThrowableException(var3);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    /**</span><br><span class="line">   * 对接口  goWorking 的调用 转变成   super.h.invoke(this, m5, new Object[]&#123;var1, var2&#125;); 调用。</span><br><span class="line">   * h 就是Proxy.java类的一个 InvocationHandler 接口 属性，</span><br><span class="line">   * 我们在创建 动态代理类实例时候都必须 传一个 InvocationHandler 接口的实例过去。 这里就是刚才我们定义的 PersonInvocationHandler 。</span><br><span class="line">   * 回到过后是不是就回到了 PersonInvocationHandler.invoke方法里面，所以 PersonInvocationHandler 是我们生成的动态代理类的拦截器，拦截所有方法调用。</span><br><span class="line">   */</span><br><span class="line">   public final void goWorking(String var1, String var2) throws  &#123;        try &#123;            super.h.invoke(this, m5, new Object[]&#123;var1, var2&#125;);</span><br><span class="line">       &#125; catch (RuntimeException | Error var4) &#123;            throw var4;</span><br><span class="line">       &#125; catch (Throwable var5) &#123;            throw new UndeclaredThrowableException(var5);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    public final int hashCode() throws  &#123;        try &#123;            return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue();</span><br><span class="line">       &#125; catch (RuntimeException | Error var2) &#123;            throw var2;</span><br><span class="line">       &#125; catch (Throwable var3) &#123;            throw new UndeclaredThrowableException(var3);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;/**</span><br><span class="line">* 静态代码块，根据动态代理实现的公共接口类接口方法 获取到所有接口方法 的 Method 实例*/</span><br><span class="line">   static &#123;        try &#123;</span><br><span class="line">           m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[]&#123;Class.forName(&quot;java.lang.Object&quot;)&#125;);</span><br><span class="line">           m4 = Class.forName(&quot;org.vincent.proxy.dynamicproxy.Person&quot;).getMethod(&quot;setName&quot;, new Class[]&#123;Class.forName(&quot;java.lang.String&quot;)&#125;);</span><br><span class="line">           m3 = Class.forName(&quot;org.vincent.proxy.dynamicproxy.Person&quot;).getMethod(&quot;getName&quot;, new Class[0]);</span><br><span class="line">           m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);</span><br><span class="line">           m5 = Class.forName(&quot;org.vincent.proxy.dynamicproxy.Person&quot;).getMethod(&quot;goWorking&quot;, new Class[]&#123;Class.forName(&quot;java.lang.String&quot;), Class.forName(&quot;java.lang.String&quot;)&#125;);</span><br><span class="line">           m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);</span><br><span class="line">       &#125; catch (NoSuchMethodException var2) &#123;            throw new NoSuchMethodError(var2.getMessage());</span><br><span class="line">       &#125; catch (ClassNotFoundException var3) &#123;            throw new NoClassDefFoundError(var3.getMessage());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Jdk为我们的生成了一个叫$Proxy0（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个类文件时默认不会保存在文件，放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建代理对象实例。通过对这个生成的代理类源码的查看，我们很容易能看出，动态代理实现的具体过程。</p>
<p>我们可以对 InvocationHandler 看做一个中介类，中介类持有一个被代理对象，被Proxy类回调。在invoke方法中调用了被代理对象的相应方法。通过聚合方式持有被代理对象的引用，把客户端对invoke的调用最终都转为对被代理对象的调用。</p>
<p>客户端代码通过代理类引用调用接口方法时，通过代理类关联的中介类对象引用来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。也就是说，动态代理Proxy类提供了模板实现，对外提供扩展点，外部通过实现InvocationHandler接口将被代理类纳入JDK代理类Proxy。</p>
<h4 id="一个典型的基于JDK动态代理创建对象过程可分为以下四个步骤："><a href="#一个典型的基于JDK动态代理创建对象过程可分为以下四个步骤：" class="headerlink" title="一个典型的基于JDK动态代理创建对象过程可分为以下四个步骤："></a>一个典型的基于JDK动态代理创建对象过程可分为以下四个步骤：</h4><p>1、通过实现InvocationHandler接口创建自己的调用处理器 IvocationHandler handler = new InvocationHandlerImpl(…);</p>
<p>2、通过为Proxy类指定ClassLoader对象和一组interface代理类需要实现的接口，创建动态代理类类文件，默认JDK并不会保存这个文件到文件中；可以保存起来观察生成的代理类结构<code>Class clazz = Proxy.getProxyClass(classLoader,new Class[]&#123;...&#125;);</code></p>
<p>3、通过上面新建的代理clazz的反射机制获取动态代理类的一个构造函数，其构造函数入参类型是调用处理器接口(<code>IvocationHandler</code>)类型 <code>Constructor constructor = clazz.getConstructor(new Class[]&#123;InvocationHandler.class&#125;);</code></p>
<p>4、通过构造函数实例创建代理类实例，此时需将调用处理器对象作为参数被传入 Interface Proxy = (Interface)constructor.newInstance(new Object[] (handler)); 为了简化对象创建过程，Proxy类中的newInstance工具方法封装了2~4，只需两步即可完成代理对象的创建。</p>
<h4 id="JDK动态代理特点总结"><a href="#JDK动态代理特点总结" class="headerlink" title="JDK动态代理特点总结"></a>JDK动态代理特点总结</h4><ul>
<li>生成的代理类：$Proxy0 extends Proxy implements Person，我们看到代理类继承了Proxy类，Java的继承机制决定了JDK动态代理类们无法实现对 类 的动态代理。所以也就决定了java动态代理只能对接口进行代理，</li>
<li>每个生成的动态代理实例都会关联一个调用处理器对象，可以通过 Proxy 提供的静态方法 getInvocationHandler 去获得代理类实例的调用处理器对象。在代理类实例上调用其代理的接口中所声明的方法时，这些方法最终都会由调用处理器的 invoke 方法执行</li>
<li>代理类的根类 java.lang.Object 中有三个方法也同样会被分派到调用处理器的 invoke 方法执行，它们是 hashCode，equals 和 toString，可能的原因有：一是因为这些方法为 public 且非 final 类型，能够被代理类覆盖； 二是因为这些方法往往呈现出一个类的某种特征属性，具有一定的区分度，所以为了保证代理类与委托类对外的一致性，这三个方法也应该被调用处理器分派到委托类执行。</li>
</ul>
<h4 id="JDK动态代理不足"><a href="#JDK动态代理不足" class="headerlink" title="JDK动态代理不足"></a>JDK动态代理不足</h4><p>JDK动态代理的代理类字节码在创建时，需要实现业务实现类所实现的接口作为参数。如果业务实现类是没有实现接口而是直接定义业务方法的话，就无法使用JDK动态代理了。(JDK动态代理重要特点是代理接口) 并且，如果业务实现类中新增了接口中没有的方法，这些方法是无法被代理的（因为无法被调用）。</p>
<p>动态代理只能对接口产生代理，不能对类产生代理</p>
<h3 id="基于CGlib-技术动态代理代理类实现-基于继承"><a href="#基于CGlib-技术动态代理代理类实现-基于继承" class="headerlink" title="基于CGlib 技术动态代理代理类实现 (基于继承)"></a>基于CGlib 技术动态代理代理类实现 (基于继承)</h3><p>Cglib是针对类来实现代理的，他的原理是对代理的目标类生成一个子类，并覆盖其中方法实现增强，因为底层是基于创建被代理类的一个子类，所以它避免了JDK动态代理类的缺陷。</p>
<p>但因为采用的是继承，所以不能对final修饰的类进行代理。final修饰的类不可继承。</p>
<h4 id="导入maven-依赖"><a href="#导入maven-依赖" class="headerlink" title="导入maven 依赖"></a>导入maven 依赖</h4><p>cglib 是基于asm 字节修改技术。导入 cglib 会间接导入 asm, ant, ant-launcher 三个jar 包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- cglib 动态代理依赖 begin --&gt;</span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">       &lt;version&gt;3.2.5&lt;/version&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line">   &lt;!-- cglib 动态代理依赖 stop --&gt;</span><br></pre></td></tr></table></figure>

<h4 id="业务类实现"><a href="#业务类实现" class="headerlink" title="业务类实现"></a>业务类实现</h4><p>cglib是针对类来实现代理的，原理是对指定的业务类生成他的一个子类，并覆盖其中的业务方法来实现代理。因为采用的是继承，所以不能对final修饰的类进行代理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package org.vincent.proxy.cglibproxy;</span><br><span class="line">/**</span><br><span class="line">* @Package: org.vincent.proxy.cglibproxy &lt;br/&gt;</span><br><span class="line">* @Description： Cglib 代理模式中 被代理的委托类 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26-17:55 &lt;br/&gt;</span><br><span class="line">*/public class Dog &#123;    public String  call() &#123;</span><br><span class="line">       System.out.println(&quot;wang wang wang&quot;);     </span><br><span class="line">          return &quot;Dog ..&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="方法拦截器-实现-MethodInterceptor-接口"><a href="#方法拦截器-实现-MethodInterceptor-接口" class="headerlink" title="方法拦截器 实现 MethodInterceptor 接口"></a>方法拦截器 实现 MethodInterceptor 接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package org.vincent.proxy.cglibproxy;</span><br><span class="line"></span><br><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Package: org.vincent.proxy.cglibproxy &lt;br/&gt;</span><br><span class="line"> * @Description： Cglib 方法拦截器,不用依赖被代理业务类的引用。  &lt;br/&gt;</span><br><span class="line"> * @author: lenovo &lt;br/&gt;</span><br><span class="line"> * @Company: PLCC &lt;br/&gt;</span><br><span class="line"> * @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line"> * @Version: 1.0 &lt;br/&gt;</span><br><span class="line"> * @Modified By: &lt;br/&gt;</span><br><span class="line"> * @Created by lenovo on 2018/12/26-17:56 &lt;br/&gt;</span><br><span class="line"> */</span><br><span class="line">public class CglibMethodInterceptor implements MethodInterceptor &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 用于生成 Cglib 动态代理类工具方法</span><br><span class="line">     *</span><br><span class="line">     * @param target 代表需要 被代理的 委托类的 Class 对象</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Object CglibProxyGeneratory(Class target) &#123;        /** 创建cglib 代理类 start */</span><br><span class="line">        // 创建加强器，用来创建动态代理类</span><br><span class="line">        Enhancer enhancer = new Enhancer();        // 为代理类指定需要代理的类，也即是父类</span><br><span class="line">        enhancer.setSuperclass(target);        // 设置方法拦截器回调引用，对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept() 方法进行拦截</span><br><span class="line">        enhancer.setCallback(this);        // 获取动态代理类对象并返回</span><br><span class="line">        return enhancer.create();        /** 创建cglib 代理类 end */</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 功能主要是在调用业务类方法之前 之后添加统计时间的方法逻辑.</span><br><span class="line">     * intercept 因为  具有 MethodProxy proxy 参数的原因 不再需要代理类的引用对象了,直接通过proxy 对象访问被代理对象的方法(这种方式更快)。</span><br><span class="line">     * 当然 也可以通过反射机制，通过 method 引用实例    Object result = method.invoke(target, args); 形式反射调用被代理类方法，</span><br><span class="line">     * target 实例代表被代理类对象引用, 初始化 CglibMethodInterceptor 时候被赋值 。但是Cglib不推荐使用这种方式</span><br><span class="line">     *</span><br><span class="line">     * @param obj    代表Cglib 生成的动态代理类 对象本身</span><br><span class="line">     * @param method 代理类中被拦截的接口方法 Method 实例</span><br><span class="line">     * @param args   接口方法参数</span><br><span class="line">     * @param proxy  用于调用父类真正的业务类方法。可以直接调用被代理类接口方法</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Throwable</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;before&quot;);</span><br><span class="line">        MonitorUtil.start();</span><br><span class="line">        Object result = proxy.invokeSuper(obj, args);        //Object result = method.invoke(target, args);</span><br><span class="line">        System.out.println(&quot;after&quot;);</span><br><span class="line">        MonitorUtil.finish(method.getName());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="一个切面，用于在方法拦截器中intercept-方法中调用真正业务方法之前-之后处理逻辑"><a href="#一个切面，用于在方法拦截器中intercept-方法中调用真正业务方法之前-之后处理逻辑" class="headerlink" title="一个切面，用于在方法拦截器中intercept 方法中调用真正业务方法之前 之后处理逻辑"></a>一个切面，用于在方法拦截器中intercept 方法中调用真正业务方法之前 之后处理逻辑</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package org.vincent.proxy.cglibproxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by PengRong on 2018/12/25.</span><br><span class="line"> * 方法用时监控类,作为一个切面 ，具有两个方法</span><br><span class="line"> */</span><br><span class="line">public class MonitorUtil &#123;</span><br><span class="line">    private static ThreadLocal&lt;Long&gt; tl = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void start() &#123;</span><br><span class="line">        tl.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 结束时打印耗时</span><br><span class="line">     *</span><br><span class="line">     * @param methodName 方法名</span><br><span class="line">     */</span><br><span class="line">    public static void finish(String methodName) &#123;</span><br><span class="line">        long finishTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(methodName + &quot;方法执行耗时&quot; + (finishTime - tl.get()) + &quot;ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Cglib测试类"><a href="#Cglib测试类" class="headerlink" title="Cglib测试类"></a>Cglib测试类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package org.vincent.proxy.cglibproxy;</span><br><span class="line"></span><br><span class="line">import net.sf.cglib.core.DebuggingClassWriter;</span><br><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Package: org.vincent.proxy.cglibproxy &lt;br/&gt;</span><br><span class="line"> * @Description： TODO &lt;br/&gt;</span><br><span class="line"> * @author: lenovo &lt;br/&gt;</span><br><span class="line"> * @Company: PLCC &lt;br/&gt;</span><br><span class="line"> * @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line"> * @Version: 1.0 &lt;br/&gt;</span><br><span class="line"> * @Modified By: &lt;br/&gt;</span><br><span class="line"> * @Created by lenovo on 2018/12/26-18:05 &lt;br/&gt;</span><br><span class="line"> */</span><br><span class="line">public class CglibTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void testCglib() throws Exception &#123;</span><br><span class="line">        System.out.println(System.getProperty(&quot;user.dir&quot;));        /** 开启 保存cglib生成的动态代理类类文件*/</span><br><span class="line">        saveGeneratedCGlibProxyFiles(System.getProperty(&quot;user.dir&quot;));        /** 第一种方法: 创建cglib 代理类 start */</span><br><span class="line">        // 创建加强器，用来创建动态代理类</span><br><span class="line">        Enhancer enhancer = new Enhancer();        // 为代理类指定需要代理的类，也即是父类</span><br><span class="line">        enhancer.setSuperclass(Dog.class);        // new 一个新的方法拦截器</span><br><span class="line">        CglibMethodInterceptor cglibMethodInterceptor = new CglibMethodInterceptor();        // 设置方法拦截器回调引用，对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept() 方法进行拦截</span><br><span class="line">        enhancer.setCallback(cglibMethodInterceptor);        // 获取动态代理类对象并返回</span><br><span class="line">        Dog dog = (Dog) enhancer.create();        /** 创建cglib 代理类 end */</span><br><span class="line">        System.out.println(dog.call());        // 对于上面这几步，可以新增一个工具方法 放置在 CglibMethodInterceptor 里面；也就有了第二种方法</span><br><span class="line">        // new 一个新的方法拦截器，该拦截器还顺带一个用于创建代理类的工具方法。看起来简单很多</span><br><span class="line">        cglibMethodInterceptor = new CglibMethodInterceptor();</span><br><span class="line">        dog = (Dog) cglibMethodInterceptor.CglibProxyGeneratory(Dog.class);</span><br><span class="line">        System.out.println(dog.call());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置保存Cglib代理生成的类文件。</span><br><span class="line">     *</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    public void saveGeneratedCGlibProxyFiles(String dir) throws Exception &#123;</span><br><span class="line">        Field field = System.class.getDeclaredField(&quot;props&quot;);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        Properties props = (Properties) field.get(null);</span><br><span class="line">        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, dir);//dir为保存文件路径</span><br><span class="line">        props.put(&quot;net.sf.cglib.core.DebuggingClassWriter.traceEnabled&quot;, &quot;true&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Cglib-总结"><a href="#Cglib-总结" class="headerlink" title="Cglib 总结"></a>Cglib 总结</h4><ul>
<li>CGlib可以传入接口也可以传入普通的类，接口使用实现的方式,普通类使用会使用继承的方式生成代理类.</li>
<li>由于是继承方式,如果是 static方法,private方法,final方法等描述的方法是不能被代理的</li>
<li>做了方法访问优化，使用建立方法索引的方式避免了传统JDK动态代理需要通过Method方法反射调用.</li>
<li>提供callback 和filter设计，可以灵活地给不同的方法绑定不同的callback。编码更方便灵活。</li>
<li>CGLIB会默认代理Object中equals,toString,hashCode,clone等方法。比JDK代理多了clone。</li>
</ul>
<h2 id="静态代理-基于JDK动态代理-基于Cglib-动态代理"><a href="#静态代理-基于JDK动态代理-基于Cglib-动态代理" class="headerlink" title="静态代理 基于JDK动态代理 基于Cglib 动态代理"></a>静态代理 基于JDK动态代理 基于Cglib 动态代理</h2><p>静态代理是通过在代码中显式编码定义一个业务实现类的代理类，在代理类中对同名的业务方法进行包装，用户通过代理类调用被包装过的业务方法；</p>
<p>JDK动态代理是通过接口中的方法名，在动态生成的代理类中调用业务实现类的同名方法；</p>
<p>CGlib动态代理是通过继承业务类，生成的动态代理类是业务类的子类，通过重写业务方法进行代理；</p>
<p>静态代理在编译时产生class字节码文件，可以直接使用，效率高。动态代理必须实现InvocationHandler接口，通过invoke调用被委托类接口方法是通过反射方式，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。 cglib代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但cglib会继承目标对象，需要重写方法，所以目标对象不能为final类。</p>
<h2 id="AOP-实现案例"><a href="#AOP-实现案例" class="headerlink" title="AOP 实现案例"></a>AOP 实现案例</h2><p>AOP的源码中用到了两种动态代理来实现拦截切入功能：jdk动态代理和cglib动态代理。两种方法同时存在，各有优劣。 jdk动态代理是由java内部的反射机制来实现的，cglib动态代理底层则是借助asm来实现的。 总的来说，反射机制在生成类的过程中比较高效，执行时候通过反射调用委托类接口方法比较慢；而asm在生成类之后的相关代理类执行过程中比较高效（可以通过将asm生成的类进行缓存，这样解决asm生成类过程低效问题）。 还有一点必须注意：jdk动态代理的应用前提，必须是委托类基于统一的接口。如果没有上述前提，jdk动态代理不能应用。 由此可以看出，jdk动态代理有一定的局限性，cglib这种第三方类库实现的动态代理应用更加广泛，且在效率上更有优势。</p>
<p>实现AOP关键特点是定义好两个角色 切点 和 切面 。 代理模式中被代理类 委托类处于切点角色，需要添加的其他比如 校验逻辑，事务，审计逻辑 属于非功能实现逻辑通过 切面类定义的方法插入进去。</p>
<h3 id="JDK动态代理-aop-实现方式"><a href="#JDK动态代理-aop-实现方式" class="headerlink" title="JDK动态代理 aop 实现方式"></a>JDK动态代理 aop 实现方式</h3><h4 id="定义切面接口，完成将通用公共方法注入到被代理类接口调用处理中"><a href="#定义切面接口，完成将通用公共方法注入到被代理类接口调用处理中" class="headerlink" title="定义切面接口，完成将通用公共方法注入到被代理类接口调用处理中"></a>定义切面接口，完成将通用公共方法注入到被代理类接口调用处理中</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package org.vincent.aop.dynamicproxy;</span><br><span class="line">/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： 定义切面接口，切面接口定义了两个切面方法，分别在切点接口方法执行前和执行后执行 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line">*/public interface IAspect &#123;    /**</span><br><span class="line">    * 在切点接口方法执行之前执行</span><br><span class="line">    * @param args 切点参数列表</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   boolean startTransaction(Object... args);    </span><br><span class="line">   /**</span><br><span class="line">    * 在切点接口方法执行之后执行</span><br><span class="line">    */</span><br><span class="line">   void endTrasaction();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="定义切面实现类"><a href="#定义切面实现类" class="headerlink" title="定义切面实现类"></a>定义切面实现类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package org.vincent.aop.dynamicproxy;</span><br><span class="line"></span><br><span class="line">import java.util.Objects;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line"> * @Description： 改类作为AOP 模型中切面角色类， 实现切面接口，切面接口定义了两个切面方法，分别在切点接口方法执行前和执行后执行 。 &lt;br/&gt;</span><br><span class="line"> * @author: lenovo &lt;br/&gt;</span><br><span class="line"> * @Company: PLCC &lt;br/&gt;</span><br><span class="line"> * @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line"> * @Version: 1.0 &lt;br/&gt;</span><br><span class="line"> * @Modified By: &lt;br/&gt;</span><br><span class="line"> * @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line"> */</span><br><span class="line">public class CustomAspect implements IAspect &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 对参数 做判空处理</span><br><span class="line">     *</span><br><span class="line">     * @param args 切点参数列表</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean startTransaction(Object... args) &#123;</span><br><span class="line">        Objects.nonNull(args);</span><br><span class="line">        boolean result = true;</span><br><span class="line">        for (Object temp : args) &#123;</span><br><span class="line">            if (Objects.isNull(temp)) &#123;</span><br><span class="line">                result = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void endTrasaction() &#123;</span><br><span class="line">        System.out.println(&quot;I get datasource here and end transaction&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义切点角色接口-因为是基于JDK实现的Aop-，所以委托类需要基于接口实现。"><a href="#定义切点角色接口-因为是基于JDK实现的Aop-，所以委托类需要基于接口实现。" class="headerlink" title="定义切点角色接口 因为是基于JDK实现的Aop ，所以委托类需要基于接口实现。"></a>定义切点角色接口 因为是基于JDK实现的Aop ，所以委托类需要基于接口实现。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package org.vincent.aop.dynamicproxy;/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： AOP基于动态代理 实现  &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line">*/public interface IUserService &#123;    </span><br><span class="line">	void saveUser(String username, String password) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="委托类实现"><a href="#委托类实现" class="headerlink" title="委托类实现"></a>委托类实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package org.vincent.aop.dynamicproxy;/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： UserService接口实现类UserServiceImpl 该类 作为AOP中切点角色，切面定义的方法插入到切点的接口方法 执行前和执行后执行。 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line">*/</span><br><span class="line">public class UserServiceImpl implements IUserService&#123;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">   public void saveUser(String username, String password) throws Exception &#123;</span><br><span class="line">       System.out.println(&quot;save user[username=&quot; + username + &quot;,password=&quot; + password + &quot;]&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JDK动态代理生成器工具类"><a href="#JDK动态代理生成器工具类" class="headerlink" title="JDK动态代理生成器工具类"></a>JDK动态代理生成器工具类</h4><p>可以看到 generatorJDKProxy 方法入参只有两个参数 一个切点接口引用，一个切面接口引用；在InvocationHandler 内部类中可以完整看到切面类方法是怎么影响切点代码执行逻辑的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package org.vincent.aop.dynamicproxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line"> * @Description： JDK动态代理类生成器 &lt;br/&gt;</span><br><span class="line"> * @author: lenovo &lt;br/&gt;</span><br><span class="line"> * @Company: PLCC &lt;br/&gt;</span><br><span class="line"> * @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line"> * @Version: 1.0 &lt;br/&gt;</span><br><span class="line"> * @Modified By: &lt;br/&gt;</span><br><span class="line"> * @Created by lenovo on 2018/12/26-16:48 &lt;br/&gt;</span><br><span class="line"> */</span><br><span class="line">public class JDKDynamicProxyGenerator &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param targetPoint 需要被代理的委托类对象</span><br><span class="line">     * @param aspect      切面对象,该对象方法将在切点方法之前或之后执行</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Object generatorJDKProxy(IUserService targetPoint, final IAspect aspect) &#123;</span><br><span class="line">        return Proxy.newProxyInstance(                /**</span><br><span class="line">                 *   委托类使用的类加载器</span><br><span class="line">                 */</span><br><span class="line">                targetPoint.getClass().getClassLoader(),                /**</span><br><span class="line">                 * 委托类实现的接口</span><br><span class="line">                 */</span><br><span class="line">                targetPoint.getClass().getInterfaces(),                /**</span><br><span class="line">                 * 生成的动态代理类关联的 执行处理器，代理我们的业务逻辑被生成的动态代理类回调</span><br><span class="line">                 * 具体逻辑代码执行,返回值为方法执行结果, 在aop模型中，委托类的接口方法称为切点。</span><br><span class="line">                 */</span><br><span class="line">                new InvocationHandler() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                        // 执行切面方法,对入参进行校验</span><br><span class="line">                        boolean prepareAction = aspect.startTransaction(args);</span><br><span class="line">                        if (prepareAction) &#123;                           // 具体逻辑代码执行,返回值为方法执行结果</span><br><span class="line">                            Object result = method.invoke(targetPoint, args);</span><br><span class="line">                            aspect.endTrasaction();</span><br><span class="line">                            return result;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            throw new RuntimeException(&quot;args: &quot; + Arrays.toString(args) + &quot;不能为null &quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package org.vincent.aop;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.vincent.aop.dynamicproxy.CustomAspect;</span><br><span class="line">import org.vincent.aop.dynamicproxy.IUserService;</span><br><span class="line">import org.vincent.aop.dynamicproxy.JDKDynamicProxyGenerator;</span><br><span class="line">import org.vincent.aop.dynamicproxy.UserServiceImpl;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Package: org.vincent &lt;br/&gt;</span><br><span class="line"> * @Description： 基于动态代理类AOP测试案例 &lt;br/&gt;</span><br><span class="line"> * @author: lenovo &lt;br/&gt;</span><br><span class="line"> * @Company: PLCC &lt;br/&gt;</span><br><span class="line"> * @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line"> * @Version: 1.0 &lt;br/&gt;</span><br><span class="line"> * @Modified By: &lt;br/&gt;</span><br><span class="line"> * @Created by lenovo on 2018/12/26-16:56 &lt;br/&gt;</span><br><span class="line"> */</span><br><span class="line">public class testAopJDKProxy &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void testJDKProxy() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;无代理前 调用方法 userService.saveUser 输出......&quot;);</span><br><span class="line">        IUserService userService = new UserServiceImpl();</span><br><span class="line">        userService.saveUser(&quot;zby&quot;, &quot;1234567890&quot;);</span><br><span class="line">        System.out.println(&quot;有代理后AOP 是怎么样的？ Proxy......&quot;);</span><br><span class="line">        IUserService proxyUserService = (IUserService) JDKDynamicProxyGenerator.generatorJDKProxy(userService, new CustomAspect());</span><br><span class="line">        proxyUserService.saveUser(&quot;zby&quot;, &quot;1234567890&quot;);        /** 制造异常,两个入参都是null   */</span><br><span class="line">        proxyUserService.saveUser(null, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Cglib-aop-实现方式"><a href="#Cglib-aop-实现方式" class="headerlink" title="Cglib aop 实现方式"></a>Cglib aop 实现方式</h3><h4 id="定义切面接口"><a href="#定义切面接口" class="headerlink" title="定义切面接口"></a>定义切面接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package org.vincent.aop.cglib;/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： 定义切面接口，切面接口定义了两个切面方法，分别在切点接口方法执行前和执行后执行 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line">*/public interface IAspect &#123;   </span><br><span class="line"> /**</span><br><span class="line">    * 在切点接口方法执行之前执行</span><br><span class="line">    */</span><br><span class="line">   void startTransaction();    </span><br><span class="line">   /**</span><br><span class="line">    * 在切点接口方法执行之后执行</span><br><span class="line">    */</span><br><span class="line">   void endTrasaction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="切面实现"><a href="#切面实现" class="headerlink" title="切面实现"></a>切面实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package org.vincent.aop.cglib;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line"> * @Description： 改类作为AOP 模型中切面角色类， 实现切面接口，切面接口定义了两个切面方法，分别在切点接口方法执行前和执行后执行 。 &lt;br/&gt;</span><br><span class="line"> * @author: lenovo &lt;br/&gt;</span><br><span class="line"> * @Company: PLCC &lt;br/&gt;</span><br><span class="line"> * @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line"> * @Version: 1.0 &lt;br/&gt;</span><br><span class="line"> * @Modified By: &lt;br/&gt;</span><br><span class="line"> * @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line"> */</span><br><span class="line">public class CustomAspect implements IAspect &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void startTransaction() &#123;</span><br><span class="line">        System.out.println(&quot;cglib. I get datasource here and start transaction&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void endTrasaction() &#123;</span><br><span class="line">        System.out.println(&quot;cglib I get datasource here and end transaction&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Cglib-是基于类实现的动态代理即业务类只需要实现类即可，不用强制必须实现某个接口为了突出这个优点这里没有实现接口"><a href="#Cglib-是基于类实现的动态代理即业务类只需要实现类即可，不用强制必须实现某个接口为了突出这个优点这里没有实现接口" class="headerlink" title="Cglib 是基于类实现的动态代理即业务类只需要实现类即可，不用强制必须实现某个接口为了突出这个优点这里没有实现接口"></a>Cglib 是基于类实现的动态代理即业务类只需要实现类即可，不用强制必须实现某个接口为了突出这个优点这里没有实现接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package org.vincent.aop.cglib;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line"> * @Description： 业务实现类UserServiceImpl 该类 作为AOP中切点角色，切面定义的方法插入到切点的接口方法 执行前和执行后执行。 &lt;br/&gt;</span><br><span class="line"> * @author: lenovo &lt;br/&gt;</span><br><span class="line"> * @Company: PLCC &lt;br/&gt;</span><br><span class="line"> * @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line"> * @Version: 1.0 &lt;br/&gt;</span><br><span class="line"> * @Modified By: &lt;br/&gt;</span><br><span class="line"> * @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line"> */</span><br><span class="line">public class UserServiceImpl &#123;</span><br><span class="line">    public void saveUser(String username, String password) &#123;</span><br><span class="line">        System.out.println(&quot;cglib save user[username=&quot; + username + &quot;,password=&quot; + password + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Cglib-动态代理生成器工具类"><a href="#Cglib-动态代理生成器工具类" class="headerlink" title="Cglib 动态代理生成器工具类"></a>Cglib 动态代理生成器工具类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package org.vincent.aop.cglib;</span><br><span class="line"></span><br><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Package: org.vincent.aop.cglib &lt;br/&gt;</span><br><span class="line"> * @Description： 基于Cglib代理类生成器工具类 &lt;br/&gt;</span><br><span class="line"> * @author: lenovo &lt;br/&gt;</span><br><span class="line"> * @Company: PLCC &lt;br/&gt;</span><br><span class="line"> * @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line"> * @Version: 1.0 &lt;br/&gt;</span><br><span class="line"> * @Modified By: &lt;br/&gt;</span><br><span class="line"> * @Created by lenovo on 2018/12/26-17:04 &lt;br/&gt;</span><br><span class="line"> */</span><br><span class="line">public class CglibProxyGenerator &#123;</span><br><span class="line">    /**</span><br><span class="line">     * @param target 需要被代理的委托类对象，Cglib需要继承该类生成子类</span><br><span class="line">     * @param aspect 切面对象,改对象方法将在切点方法之前或之后执行</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Object generatorCglibProxy(final Object target, final IAspect aspect) &#123;        //3.1 new Enhancer</span><br><span class="line">        Enhancer enhancer = new Enhancer();        //3.2 设置需要代理的父类</span><br><span class="line">        enhancer.setSuperclass(target.getClass());        //3.3 设置回调</span><br><span class="line">        enhancer.setCallback(new MethodInterceptor() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span><br><span class="line">                    throws Throwable &#123;                // 执行切面方法</span><br><span class="line">                aspect.startTransaction();                // 具体逻辑代码执行,返回值为方法执行结果</span><br><span class="line">                Object result = methodProxy.invokeSuper(proxy, args);                // 执行切面方法</span><br><span class="line">                aspect.endTrasaction();                // 返回方法执行结果</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);        // 3.4 创建代理对象</span><br><span class="line">        return enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试类-1"><a href="#测试类-1" class="headerlink" title="测试类"></a>测试类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package org.vincent.aop;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.vincent.aop.cglib.CglibProxyGenerator;</span><br><span class="line">import org.vincent.aop.cglib.CustomAspect;</span><br><span class="line">import org.vincent.aop.cglib.UserServiceImpl;</span><br><span class="line">/**</span><br><span class="line">* @Package: org.vincent &lt;br/&gt;</span><br><span class="line">* @Description： 基于动态代理类AOP测试案例 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26-16:56 &lt;br/&gt;</span><br><span class="line">*/public class testAopCglibKProxy &#123;   </span><br><span class="line">   @Test</span><br><span class="line">   public void testCglibProxy() &#123;</span><br><span class="line">       System.out.println(&quot;before Proxy......&quot;);</span><br><span class="line">       UserServiceImpl userService = new UserServiceImpl();</span><br><span class="line">       userService.saveUser(&quot;zby&quot;, &quot;1234567890&quot;);</span><br><span class="line">       System.out.println(&quot;引入Cglib  Proxy代理库 后......&quot;);</span><br><span class="line">       UserServiceImpl proxyUserService = (UserServiceImpl) CglibProxyGenerator.generatorCglibProxy(userService, new CustomAspect());</span><br><span class="line">       proxyUserService.saveUser(&quot;zby&quot;, &quot;1234567890&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AspectJ-实现-AOP-效果"><a href="#AspectJ-实现-AOP-效果" class="headerlink" title="AspectJ 实现 AOP 效果"></a>AspectJ 实现 AOP 效果</h3><p>AOP 实现的关键就在于 AOP 框架自动创建的 AOP 代理，AOP 代理则可分为静态代理和动态代理两大类:</p>
<ul>
<li>静态代理是指使用 AOP 框架提供的命令进行编译，从而在编译阶段通过AOP框架指令生成 AOP 代理类，因此也称为编译时增强；还有一种静态代理是编写代码实现不用工具；这种方式一般是代理模式会使用。</li>
<li>动态代理则在运行时借助于 JDK 动态代理、CGLIB 等在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。</li>
</ul>
<h4 id="基于-AspectJ-的编译时增强进行-AOP-POM-依赖"><a href="#基于-AspectJ-的编译时增强进行-AOP-POM-依赖" class="headerlink" title="基于 AspectJ 的编译时增强进行 AOP POM 依赖"></a>基于 AspectJ 的编译时增强进行 AOP POM 依赖</h4><p>原生 AspectJ 不依赖Spring案例, 基于 AspectJ 的编译时增强进行 AOP 它是在编译期修改字节码，增强功能；并不会生成新的代理类字节码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- AspectJ begin--&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">	   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">	   &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;</span><br><span class="line">	   &lt;version&gt;1.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;</span><br><span class="line">	   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">	   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">	   &lt;version&gt;1.9.2&lt;/version&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line">   &lt;!-- AspectJ stop--&gt;</span><br></pre></td></tr></table></figure>

<h2 id="动态代理-使用场景"><a href="#动态代理-使用场景" class="headerlink" title="动态代理 使用场景"></a>动态代理 使用场景</h2><ul>
<li>日志集中打印</li>
<li>事务</li>
<li>权限管理</li>
<li>AOP</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Vic Vagrant</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://vagrantpoet.site/2020/07/27/Java/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E3%80%81CGlib%E3%80%81AOP/">https://vagrantpoet.site/2020/07/27/Java/动态代理、CGlib、AOP/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://vagrantpoet.site" target="_blank">Vagrantの日常笔记</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/07/26/Java/CGLIB%E5%92%8CJava%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CGLIB和Java动态代理的区别</div></div></a></div><div class="next-post pull-right"><a href="/2020/08/16/%E5%85%AB%E8%82%A1%E6%96%87/%E6%A1%86%E6%9E%B6/%E6%A1%86%E6%9E%B6-5-Mybatis/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">框架 - 5.Mybatis</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/05/20/Java/ABA问题产生及解决方案/" title="ABA问题产生及解决方案"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-09-12</div><div class="title">ABA问题产生及解决方案</div></div></a></div><div><a href="/2020/07/26/Java/CGLIB和Java动态代理的区别/" title="CGLIB和Java动态代理的区别"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-09-12</div><div class="title">CGLIB和Java动态代理的区别</div></div></a></div><div><a href="/2020/03/17/Java/GC算法之三_标记-压缩算法/" title="GC算法之 标记-压缩算法"><img class="cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-09-12</div><div class="title">GC算法之 标记-压缩算法</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/LVicBlack/IMG/root/20210907231006.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Vic Vagrant</div><div class="author-info__description">欲速则不达</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">76</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">27</div></a></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">印象笔记搬运中。。。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%9C%89%E5%A6%82%E4%B8%8B%E4%BA%94%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">Java 代理模式实现方式，主要有如下五种方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Notes"><span class="toc-number">2.</span> <span class="toc-text">Notes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">静态代理实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.1.</span> <span class="toc-text">实现步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cat%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.1.1.</span> <span class="toc-text">Cat接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E7%B1%BB-Lion"><span class="toc-number">3.1.2.</span> <span class="toc-text">委托类 Lion</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E7%B1%BB%E8%A7%92%E8%89%B2-FeederProxy"><span class="toc-number">3.1.3.</span> <span class="toc-text">代理类角色(FeederProxy)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E6%B5%8B%E8%AF%95"><span class="toc-number">3.1.4.</span> <span class="toc-text">静态代理类测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB-%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">动态代理类(基于接口实现)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E6%B6%89%E5%8F%8A%E8%A7%92%E8%89%B2"><span class="toc-number">4.1.</span> <span class="toc-text">动态代理类涉及角色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EJDK%E6%8A%80%E6%9C%AF-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%E6%8A%80%E6%9C%AF%E6%A0%B8%E5%BF%83-Proxy%E7%B1%BB%E5%92%8C%E4%B8%80%E4%B8%AA-InvocationHandler-%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.2.</span> <span class="toc-text">基于JDK技术 动态代理类技术核心 Proxy类和一个 InvocationHandler 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">4.2.1.</span> <span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AC%E5%85%B1%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">公共接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%8C%E7%AD%89%E4%B8%8B%E8%A2%AB%E5%A7%94%E6%89%98%EF%BC%8C%E8%A2%AB%E4%BB%A3%E7%90%86%E7%9A%84%E7%B1%BB-SoftwareEngineer-java"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">具体实现类，等下被委托，被代理的类 SoftwareEngineer.java</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#InvocationHandler-%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0-PersonInvocationHandler-java"><span class="toc-number">4.2.1.3.</span> <span class="toc-text">InvocationHandler 接口实现 PersonInvocationHandler.java</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PersonInvocationHandler-invoke-%E6%96%B9%E6%B3%95%E4%B8%AD%E6%B7%BB%E5%8A%A0%E7%9A%84%E5%85%AC%E5%85%B1%E4%BB%A3%E7%A0%81%EF%BC%8C%E8%BF%99%E9%87%8C%E7%AE%80%E5%8D%95%E4%BB%A5%E7%BB%9F%E8%AE%A1%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E4%B8%BA%E9%80%BB%E8%BE%91"><span class="toc-number">4.2.1.4.</span> <span class="toc-text">PersonInvocationHandler invoke 方法中添加的公共代码，这里简单以统计方法执行时间为逻辑</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E7%9A%84%E6%98%AF-%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E7%B1%BB"><span class="toc-number">4.2.1.5.</span> <span class="toc-text">最后的是 怎么创建代理类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90JDK%E7%94%9F%E6%88%90%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%B1%BB"><span class="toc-number">4.2.2.</span> <span class="toc-text">解析JDK生成的动态代理类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%85%B8%E5%9E%8B%E7%9A%84%E5%9F%BA%E4%BA%8EJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B%E5%8F%AF%E5%88%86%E4%B8%BA%E4%BB%A5%E4%B8%8B%E5%9B%9B%E4%B8%AA%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-number">4.2.3.</span> <span class="toc-text">一个典型的基于JDK动态代理创建对象过程可分为以下四个步骤：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%89%B9%E7%82%B9%E6%80%BB%E7%BB%93"><span class="toc-number">4.2.4.</span> <span class="toc-text">JDK动态代理特点总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8D%E8%B6%B3"><span class="toc-number">4.2.5.</span> <span class="toc-text">JDK动态代理不足</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ECGlib-%E6%8A%80%E6%9C%AF%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%BB%A3%E7%90%86%E7%B1%BB%E5%AE%9E%E7%8E%B0-%E5%9F%BA%E4%BA%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">4.3.</span> <span class="toc-text">基于CGlib 技术动态代理代理类实现 (基于继承)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5maven-%E4%BE%9D%E8%B5%96"><span class="toc-number">4.3.1.</span> <span class="toc-text">导入maven 依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E7%B1%BB%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.2.</span> <span class="toc-text">业务类实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA%E5%99%A8-%E5%AE%9E%E7%8E%B0-MethodInterceptor-%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.3.3.</span> <span class="toc-text">方法拦截器 实现 MethodInterceptor 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%88%87%E9%9D%A2%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%9C%A8%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%ADintercept-%E6%96%B9%E6%B3%95%E4%B8%AD%E8%B0%83%E7%94%A8%E7%9C%9F%E6%AD%A3%E4%B8%9A%E5%8A%A1%E6%96%B9%E6%B3%95%E4%B9%8B%E5%89%8D-%E4%B9%8B%E5%90%8E%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-number">4.3.4.</span> <span class="toc-text">一个切面，用于在方法拦截器中intercept 方法中调用真正业务方法之前 之后处理逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cglib%E6%B5%8B%E8%AF%95%E7%B1%BB"><span class="toc-number">4.3.5.</span> <span class="toc-text">Cglib测试类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cglib-%E6%80%BB%E7%BB%93"><span class="toc-number">4.3.6.</span> <span class="toc-text">Cglib 总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86-%E5%9F%BA%E4%BA%8EJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-%E5%9F%BA%E4%BA%8ECglib-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">静态代理 基于JDK动态代理 基于Cglib 动态代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP-%E5%AE%9E%E7%8E%B0%E6%A1%88%E4%BE%8B"><span class="toc-number">6.</span> <span class="toc-text">AOP 实现案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-aop-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">6.1.</span> <span class="toc-text">JDK动态代理 aop 实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%88%87%E9%9D%A2%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%AE%8C%E6%88%90%E5%B0%86%E9%80%9A%E7%94%A8%E5%85%AC%E5%85%B1%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5%E5%88%B0%E8%A2%AB%E4%BB%A3%E7%90%86%E7%B1%BB%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E5%A4%84%E7%90%86%E4%B8%AD"><span class="toc-number">6.1.1.</span> <span class="toc-text">定义切面接口，完成将通用公共方法注入到被代理类接口调用处理中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%88%87%E9%9D%A2%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">6.1.2.</span> <span class="toc-text">定义切面实现类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%88%87%E7%82%B9%E8%A7%92%E8%89%B2%E6%8E%A5%E5%8F%A3-%E5%9B%A0%E4%B8%BA%E6%98%AF%E5%9F%BA%E4%BA%8EJDK%E5%AE%9E%E7%8E%B0%E7%9A%84Aop-%EF%BC%8C%E6%89%80%E4%BB%A5%E5%A7%94%E6%89%98%E7%B1%BB%E9%9C%80%E8%A6%81%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E3%80%82"><span class="toc-number">6.1.3.</span> <span class="toc-text">定义切点角色接口 因为是基于JDK实现的Aop ，所以委托类需要基于接口实现。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E7%B1%BB%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.1.4.</span> <span class="toc-text">委托类实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90%E5%99%A8%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">6.1.5.</span> <span class="toc-text">JDK动态代理生成器工具类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%B1%BB"><span class="toc-number">6.1.6.</span> <span class="toc-text">测试类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cglib-aop-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">Cglib aop 实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%88%87%E9%9D%A2%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.2.1.</span> <span class="toc-text">定义切面接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E9%9D%A2%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.2.2.</span> <span class="toc-text">切面实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cglib-%E6%98%AF%E5%9F%BA%E4%BA%8E%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8D%B3%E4%B8%9A%E5%8A%A1%E7%B1%BB%E5%8F%AA%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%8D%B3%E5%8F%AF%EF%BC%8C%E4%B8%8D%E7%94%A8%E5%BC%BA%E5%88%B6%E5%BF%85%E9%A1%BB%E5%AE%9E%E7%8E%B0%E6%9F%90%E4%B8%AA%E6%8E%A5%E5%8F%A3%E4%B8%BA%E4%BA%86%E7%AA%81%E5%87%BA%E8%BF%99%E4%B8%AA%E4%BC%98%E7%82%B9%E8%BF%99%E9%87%8C%E6%B2%A1%E6%9C%89%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.2.3.</span> <span class="toc-text">Cglib 是基于类实现的动态代理即业务类只需要实现类即可，不用强制必须实现某个接口为了突出这个优点这里没有实现接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cglib-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%94%9F%E6%88%90%E5%99%A8%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">6.2.4.</span> <span class="toc-text">Cglib 动态代理生成器工具类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%B1%BB-1"><span class="toc-number">6.2.5.</span> <span class="toc-text">测试类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AspectJ-%E5%AE%9E%E7%8E%B0-AOP-%E6%95%88%E6%9E%9C"><span class="toc-number">6.3.</span> <span class="toc-text">AspectJ 实现 AOP 效果</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-AspectJ-%E7%9A%84%E7%BC%96%E8%AF%91%E6%97%B6%E5%A2%9E%E5%BC%BA%E8%BF%9B%E8%A1%8C-AOP-POM-%E4%BE%9D%E8%B5%96"><span class="toc-number">6.3.1.</span> <span class="toc-text">基于 AspectJ 的编译时增强进行 AOP POM 依赖</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.</span> <span class="toc-text">动态代理 使用场景</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/11/01/Java/jstat%E6%9F%A5%E7%9C%8Bgc%E6%83%85%E5%86%B5/" title="jstat查看gc情况(JAVA1.8)"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="jstat查看gc情况(JAVA1.8)"/></a><div class="content"><a class="title" href="/2021/11/01/Java/jstat%E6%9F%A5%E7%9C%8Bgc%E6%83%85%E5%86%B5/" title="jstat查看gc情况(JAVA1.8)">jstat查看gc情况(JAVA1.8)</a><time datetime="2021-11-01T05:17:03.000Z" title="发表于 2021-11-01 13:17:03">2021-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/01/Java/JAVA%20JVM%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%AF%B9%E6%AF%94%E5%92%8C%E6%95%B4%E7%90%86/" title="JAVA JVM不同版本对比和整理"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JAVA JVM不同版本对比和整理"/></a><div class="content"><a class="title" href="/2021/11/01/Java/JAVA%20JVM%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E5%AF%B9%E6%AF%94%E5%92%8C%E6%95%B4%E7%90%86/" title="JAVA JVM不同版本对比和整理">JAVA JVM不同版本对比和整理</a><time datetime="2021-11-01T02:17:03.000Z" title="发表于 2021-11-01 10:17:03">2021-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/01/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%8BJVM%E8%B0%83%E4%BC%98%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF/" title="高并发场景下JVM调优实践之路"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="高并发场景下JVM调优实践之路"/></a><div class="content"><a class="title" href="/2021/11/01/Java/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%8BJVM%E8%B0%83%E4%BC%98%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF/" title="高并发场景下JVM调优实践之路">高并发场景下JVM调优实践之路</a><time datetime="2021-10-31T22:17:03.000Z" title="发表于 2021-11-01 06:17:03">2021-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/20/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes%EF%BC%88%E4%B9%A6%E7%B1%8D%EF%BC%89%E7%AC%94%E8%AE%B0/Kubernetes%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2%E5%88%A9%E5%99%A8%EF%BC%9Akubeadm/" title="Kubernetes一键部署利器：kubeadm"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Kubernetes一键部署利器：kubeadm"/></a><div class="content"><a class="title" href="/2021/10/20/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90kubernetes%EF%BC%88%E4%B9%A6%E7%B1%8D%EF%BC%89%E7%AC%94%E8%AE%B0/Kubernetes%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2%E5%88%A9%E5%99%A8%EF%BC%9Akubeadm/" title="Kubernetes一键部署利器：kubeadm">Kubernetes一键部署利器：kubeadm</a><time datetime="2021-10-20T02:06:00.000Z" title="发表于 2021-10-20 10:06:00">2021-10-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/19/MySQL/Semisynchronous%20Replication%20%E5%8D%8A%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F/" title="Semisynchronous Replication 半同步复制"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Semisynchronous Replication 半同步复制"/></a><div class="content"><a class="title" href="/2021/10/19/MySQL/Semisynchronous%20Replication%20%E5%8D%8A%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F/" title="Semisynchronous Replication 半同步复制">Semisynchronous Replication 半同步复制</a><time datetime="2021-10-19T08:06:00.000Z" title="发表于 2021-10-19 16:06:00">2021-10-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Vic Vagrant</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>