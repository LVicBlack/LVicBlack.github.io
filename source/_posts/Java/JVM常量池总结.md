---
title: JVM常量池总结
date: 2021-11-02 13：17：03
categories:  
- Java
- JVM
tags: 
- Java
- JVM
---

### 常量池存储的内容

![](https：//cdn.jsdelivr.net/gh/LVicBlack/IMG/root/20211102175905.png)

### Class文件常量池（Class Constant Pool）

每个Class文件都会有一个单独的常量池，我们称为Class文件常量池，我们可以用javap命令反汇编Class文件，可以查看java编译器为我们生成的字节码。通过它，我们可以对照源代码和字节码，从而了解很多编译器内部的工作。而在得到的结果中的Constant pool字段就是class文件常量池.

![](https：//cdn.jsdelivr.net/gh/LVicBlack/IMG/root/20211102180400.png)

从上图可以看出，Class文件中包括：

- 魔数：它的唯一作用是确定这个文件是否可以被JVM接受。很多文件储存标准中都使用魔数来进行身份识别的，其占用这个文件的前四个字节。

- 版本号：第5和第6个字节是副版本号，第7个和第8个是主版本号。

- 常量池计数器：也就是常量池的入口，代表常量池的容量计数器。

- 常量池：
	- 字面量(literal)：字面量就是我们所说的常量概念，如：
		1. 文本字符串、
		2. 被声明为final的常量值。
		3. 基本数据类型的值
	- 符号引用：而符号引用则属于编译原理的方面的概念。是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。包括以下三类常量：
		1. 类和接口的全限定名
		2. 字段的名称和描述符
		3. 方法的名称和描述符

静态常量池用于**存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。**其中符号引用其实引用的就是常量池里面的字符串，但符号引用不是直接存储字符串，而是存储字符串在常量池里的索引。

#### 符号引用、直接引用、句柄

- 符号引用：
	符号引用以一组符号来描述所引用的目标。符号引用可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
	在编译的时候一个每个java类都会被编译成一个class文件，但在编译的时候虚拟机并不知道所引用类的地址，多以就用符号引用来代替，而在这个解析阶段就是为了把这个符号引用转化成为真正的地址的阶段。

- 直接引用：
	直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。
	如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。

- 句柄：
	- JVM中有两种主流的访问对象的方式：直接指针访问和句柄访问
		- 直接指针访问：Java中的引用类型变量储存的将会直接就是堆中对象的地址，而这个对象的地址应该包含一个指向方法区中对象类型的数据，这样的优点是直接就能访问到对象本身，速度更快，HotSpot也是采用这样的方式实现的。
		- 句柄访问：在Java堆中会划分出一个区域储存句柄池，句柄池将会储存对象的地址和对象类型数据的地址，而Java中引用类型变量储存的也将会是句柄池的地址，这样的好处是，当对象发生移动时，只需要改变句柄池中的内容就好了。

### 运行时常量池（Runtime Constant Pool）

运行时常量池主要**存放**两类信息：分别是字面量和符号引用。
对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，**一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。**

运行时常量池还有个更重要的的特征：动态性。
Java要求，编译期的常量池的内容可以进入运行时常量池，运行时产生的常量也可以放入池中。常用的是String类的intern()方法。

### 字符串常量池（string pool）

字符串常量池存在运行时常量池之中（在JDK7之前存在运行时常量池之中，在JDK7已经将其转移到堆中）。

字符串常量池的存在使JVM提高了性能和减少了内存开销。

>使用字符串常量池，每当我们使用字面量（String s=”1”;）创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就将此字符串对象的地址赋值给引用s（引用s在Java栈中）。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中，并将此字符串对象的地址赋值给引用s（引用s在Java栈中）。

>使用字符串常量池，每当我们使用关键字new（String s=new String(”1”);）创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么不再在字符串常量池创建该字符串对象，而直接堆中创建该对象的副本，然后将堆中对象的地址赋值给引用s，如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中，然后在堆中创建该对象的副本，然后将堆中对象的地址赋值给引用s。

### String intern()方法

intern() 方法返回字符串对象的规范化表示形式。
它遵循以下规则：对于任意两个字符串 s 和 t，当且仅当 s.equals(t) 为 true 时，s.intern() == t.intern() 才为 true。

#### 例1
```
String a = new String("ab");
String b = new String("ab");
String c = "ab";
String d = "a" + "b";
String e = "b";
String f = "a" + e;

System.out.println(b.intern() == a);
System.out.println(b.intern() == c);
System.out.println(b.intern() == d);
System.out.println(b.intern() == f);
System.out.println(b.intern() == a.intern());
```

```
false
true
true
false
true
```

- 字符串相加的时候，都是静态字符串的结果会添加到字符串池，如果其中含有变量（如f中的e）则不会进入字符串池中。
- 字符串一旦进入字符串池中，就会先查找池中有无此对象。
- 调用intern的时候，如果字符串池中有此对象，则让对象引用指向此对象。如果无此对象，则先创建此对象，再让对象引用指向此对象。

#### 例2

```
String s = new String("1");
s.intern();
String s2 = "1";
System.out.println(s == s2);
 
String s3 = new String("1") + new String("1");
s3.intern();
String s4 = "11";
System.out.println(s3 == s4);
```

输出结果为：
```
JDK1.6以及以下：false false
JDK1.7以及以上：false true
```

再分别调整上面代码的顺序：

```
String s = new String("1");
String s2 = "1";
s.intern();
System.out.println(s == s2);
 
String s3 = new String("1") + new String("1");
String s4 = "11";
s3.intern();
System.out.println(s3 == s4);
```

输出结果为：
```
JDK1.6以及以下：false false
JDK1.7以及以上：false false
```

分析：

String s = newString("1")，生成了常量池中的“1” 和堆空间中的字符串对象。
s.intern()，这一行的作用是s对象去常量池中寻找后发现"1"已经存在于常量池中了。
String s2 = "1"，这行代码是生成一个s2的引用指向常量池中的“1”对象。
结果就是 s 和 s2 的引用地址明显不同。因此返回了false。

String s3 = new String("1") + newString("1")，这行代码在字符串常量池中生成“1” ，并在堆空间中生成s3引用指向的对象（内容为"11"）。注意此时常量池中是没有 “11”对象的。

s3.intern()，这一行代码，是将 s3中的“11”字符串放入 String 常量池中，此时常量池中不存在“11”字符串，**JDK1.6的做法是直接在常量池中生成一个 "11" 的对象。**

**但是在JDK1.7中，常量池中不需要再存储一份对象了，可以直接存储堆中的引用。这份引用直接指向 s3 引用的对象，也就是说s3.intern() ==s3会返回true。**

String s4 = "11"， 这一行代码会直接去常量池中创建，但是发现已经有这个对象了，此时也就是指向 s3 引用对象的一个引用。因此s3 == s4返回了true。

### 三个常量池的关系

JVM在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。

**[静态常量池]**用于存放编译期生成的各种字面量和符号引用，而当类加载到内存中后，jvm就会将**[静态常量池]**中的内容存放到**[运行时常量池中]**。而**[字符串常量池]**存的是引用值，其存在于运行时常量池之中。















































