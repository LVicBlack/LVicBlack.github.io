---
title: 白话容器基础（三）：深入理解容器镜像
date: 2021-09-26 10:06:00
categories: 
- 深入剖析kubernetes（书籍）笔记
- 容器技术概念入门
tags:
- kubernetes
---

## 深入理解容器镜像

### 容器里的进程看到的文件系统

#### clone方法的参数

```
long do_mount(char *dev_name,char*dir_name,char*type_page,unsigned long flags,void *data_page)  

dev_name指的是要挂载文件系统的名字，如tmpfs,
dir_name指的是文件系统要被挂载的目标目录
type_page指的是要挂载的文件系统的类型
flags指的是挂载选项，如MS_RDONLY等等
data_page指的是一些额外选项等，如wait关键字

```

#### 启用 Mount Namespace（即：CLONE_NEWNS 标志）
```
static char container_stack[STACK_SIZE];
char* const container_args[] = {
  "/bin/bash",
  NULL
};

int container_main(void* arg)
{  
  printf("Container - inside the container!\n");
  execv(container_args[0], container_args);
  printf("Something's wrong!\n");
  return 1;
}

int main()
{
  printf("Parent - start a container!\n");
  int container_pid = clone(container_main, container_stack+STACK_SIZE, CLONE_NEWNS | SIGCHLD , NULL);
  waitpid(container_pid, NULL, 0);
  printf("Parent - container stopped!\n");
  return 0;
}
```
在“容器”里执行一下 ls 指令的话， /tmp 目录下的内容跟宿主机的内容是一样的。

>即使开启了 Mount Namespace，容器进程看到的文件系统也跟宿主机完全一样。
>
>原因：Mount Namespace 修改的，是容器进程对文件系统“挂载点”的认知。但是，这也就意味着，只有在“挂载”这个操作发生之后，进程的视图才会被改变。而在此之前，新创建的容器会直接继承宿主机的各个挂载点。

#### 添加挂载点
创建新进程时，除了声明要启用 Mount Namespace 之外，我们还可以告诉容器进程，有哪些目录需要重新挂载，就比如这个 /tmp 目录。

```
int container_main(void* arg)
{
  printf("Container - inside the container!\n");
  // 如果你的机器的根目录的挂载类型是shared，那必须先重新挂载根目录
  // mount("", "/", NULL, MS_PRIVATE, "");
  mount("none", "/tmp", "tmpfs", 0, "");
  execv(container_args[0], container_args);
  printf("Something's wrong!\n");
  return 1;
}
```

在容器进程启动之前，加上了一句 mount(“none”, “/tmp”, “tmpfs”, 0, “”) 语句。就这样，我告诉了容器以 tmpfs（内存盘）格式，重新挂载了 /tmp 目录。

在“容器”里执行一下 ls 指令的话， /tmp 变成了一个空目录，这意味着重新挂载生效了。

我们可以用 mount -l 检查一下：

```
$ mount -l | grep tmpfs
none on /tmp type tmpfs (rw,relatime)
```

因为我们创建的新进程启用了 Mount Namespace，所以这次重新挂载的操作，只在容器进程的 Mount Namespace 中有效。如果在宿主机上用 mount -l 来检查一下这个挂载，你会发现它是不存在的：

```
# 在宿主机上
$ mount -l | grep tmpfs
```

>**Mount Namespace 跟其他 Namespace 的使用略有不同的地方：它对容器进程视图的改变，一定是伴随着挂载操作（mount）才能生效。**

#### chroot - “change root file system”

mount namespace可以隔离文件系统，生效条件是在容器启动前重新挂载，chroot可以帮助在shell环境挂载。
将宿主机的新目录通过chroot变成了进程的根目录，实现进程和宿主机的文件目录视图隔离。

**实际上，Mount Namespace 正是基于对 chroot 的不断改良才被发明出来的，它也是 Linux 操作系统里的第一个 Namespace。**

为了能够让容器的这个根目录看起来更“真实”，我们一般会在这个容器的根目录下挂载一个完整操作系统的文件系统，比如 Ubuntu16.04 的 ISO。

**而这个挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：rootfs（根文件系统）。**

### rootfs

一个最常见的 rootfs，或者说容器镜像，会包括如下所示的一些目录和文件

```
$ ls /
bin dev etc home lib lib64 mnt opt proc root run sbin sys tmp usr var
```
#### Docker核心原理
>1. 启用 Linux Namespace 配置；**隔离**
>2. 设置指定的 Cgroups 参数；**限制**
>3. 切换进程的根目录（Change Root）。**挂载**

Docker 项目在最后一步的切换上会优先使用 pivot_root 系统调用，如果系统不支持，才会使用 chroot。

>pivot_root与chroot的区别：
>chroot是只改变即将运行的 某进程的根目录。pviot_root主要是把整个系统切换到一个新的root目录，然后去掉对之前rootfs的依赖，以便于可以umount 之前的文件系统（pivot_root需要root权限）










































