---
title: 并发 - 1.JMM
date: 2020-08-20 17:31:03
categories: 
- 八股文
- 并发
tags:
- 并发
- 面试
---

### **JMM 8**

#### **Q1：JMM 的作用是什么？**

Java 线程的通信由 JMM 控制，JMM 的主要目的是定义程序中各种变量的访问规则。变量包括实例字段、静态字段，但不包括局部变量与方法参数，因为它们是线程私有的，不存在多线程竞争。JMM 遵循一个基本原则：只要不改变程序执行结果，编译器和处理器怎么优化都行。例如编译器分析某个锁只会单线程访问就消除锁，某个 volatile 变量只会单线程访问就把它当作普通变量。

JMM 规定所有变量都存储在主内存，每条线程有自己的工作内存，工作内存中保存被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作空间进行，不能直接读写主内存数据。不同线程间无法直接访问对方工作内存中的变量，线程通信必须经过主内存。

关于主内存与工作内存的交互，即变量如何从主内存拷贝到工作内存、从工作内存同步回主内存，JMM 定义了 8 种原子操作：

|**操作**|**作用变量范围**|**作用**                              |
|--------|----------------|--------------------------------------|
|lock    |主内存          |把变量标识为线程独占状态              |
|unlock  |主内存          |释放处于锁定状态的变量                |
|read    |主内存          |把变量值从主内存传到工作内存          |
|load    |工作内存        |把 read 得到的值放入工作内存的变量副本|
|user    |工作内存        |把工作内存中的变量值传给执行引擎      |
|assign  |工作内存        |把从执行引擎接收的值赋给工作内存变量  |
|store   |工作内存        |把工作内存的变量值传到主内存          |
|write   |主内存          |把 store 取到的变量值放入主内存变量中 |

---

#### **Q2：as\-if\-serial 是什么？**

不管怎么重排序，单线程程序的执行结果不能改变，编译器和处理器必须遵循 as\-if\-serial 语义。

为了遵循 as\-if\-serial，编译器和处理器不会对存在数据依赖关系的操作重排序，因为这种重排序会改变执行结果。但是如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。

as\-if\-serial 把单线程程序保护起来，给程序员一种幻觉：单线程程序是按程序的顺序执行的。

---

#### **Q3：happens\-before 是什么？**

先行发生原则，JMM 定义的两项操作间的偏序关系，是判断数据是否存在竞争的重要手段。

JMM 将 happens\-before 要求禁止的重排序按是否会改变程序执行结果分为两类。对于会改变结果的重排序 JMM 要求编译器和处理器必须禁止，对于不会改变结果的重排序，JMM 不做要求。

JMM 存在一些天然的 happens\-before 关系，无需任何同步器协助就已经存在。如果两个操作的关系不在此列，并且无法从这些规则推导出来，它们就没有顺序性保障，虚拟机可以对它们随意进行重排序。


	* 程序次序规则：一个线程内写在前面的操作先行发生于后面的。
	* 管程锁定规则： unlock 操作先行发生于后面对同一个锁的 lock 操作。
	* volatile 规则：对 volatile 变量的写操作先行发生于后面的读操作。
	* 线程启动规则：线程的 start 方法先行发生于线程的每个动作。
	* 线程终止规则：线程中所有操作先行发生于对线程的终止检测。
	* 对象终结规则：对象的初始化先行发生于 finalize 方法。
	* 传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C 。



---

#### **Q4：as\-if\-serial 和 happens\-before 有什么区别？**

as\-if\-serial 保证单线程程序的执行结果不变，happens\-before 保证正确同步的多线程程序的执行结果不变。

这两种语义的目的都是为了在不改变程序执行结果的前提下尽可能提高程序执行并行度。

---

#### **Q5：什么是指令重排序？**

为了提高性能，编译器和处理器通常会对指令进行重排序，重排序指从源代码到指令序列的重排序，分为三种：① 编译器优化的重排序，编译器在不改变单线程程序语义的前提下可以重排语句的执行顺序。② 指令级并行的重排序，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。③ 内存系统的重排序。

---

#### **Q6：原子性、可见性、有序性分别是什么？**

**原子性**

基本数据类型的访问都具备原子性，例外就是 long 和 double，虚拟机将没有被 volatile 修饰的 64 位数据操作划分为两次 32 位操作。

如果应用场景需要更大范围的原子性保证，JMM 还提供了 lock 和 unlock 操作满足需求，尽管 JVM 没有把这两种操作直接开放给用户使用，但是提供了更高层次的字节码指令 monitorenter 和 monitorexit，这两个字节码指令反映到 Java 代码中就是 synchronized。

**可见性**

可见性指当一个线程修改了共享变量时，其他线程能够立即得知修改。JMM 通过在变量修改后将值同步回主内存，在变量读取前从主内存刷新的方式实现可见性，无论普通变量还是 volatile 变量都是如此，区别是 volatile 保证新值能立即同步到主内存以及每次使用前立即从主内存刷新。

除了 volatile 外，synchronized 和 final 也可以保证可见性。同步块可见性由"对一个变量执行 unlock 前必须先把此变量同步回主内存，即先执行 store 和 write"这条规则获得。final 的可见性指：被 final 修饰的字段在构造方法中一旦初始化完成，并且构造方法没有把 this 引用传递出去，那么其他线程就能看到 final 字段的值。

**有序性**

有序性可以总结为：在本线程内观察所有操作是有序的，在一个线程内观察另一个线程，所有操作都是无序的。前半句指 as\-if\-serial 语义，后半句指指令重排序和工作内存与主内存延迟现象。

Java 提供 volatile 和 synchronized 保证有序性，volatile 本身就包含禁止指令重排序的语义，而 synchronized 保证一个变量在同一时刻只允许一条线程对其进行 lock 操作，确保持有同一个锁的两个同步块只能串行进入。

---

#### **Q7：谈一谈 volatile**

JMM 为 volatile 定义了一些特殊访问规则，当变量被定义为 volatile 后具备两种特性：

* 当一条线程修改了变量值，新值对于其他线程来说是立即可以得知的。volatile 变量在各个线程的工作内存中不存在一致性问题，但 Java 的运算操作符并非原子操作，导致 volatile 变量运算在并发下仍不安全。
    **保证变量对所有线程可见**
* 使用 volatile 变量进行写操作，汇编指令带有 lock 前缀，相当于一个内存屏障，后面的指令不能重排到内存屏障之前。
    使用 lock 前缀引发两件事：① 将当前处理器缓存行的数据写回系统内存。②使其他处理器的缓存无效。相当于对缓存变量做了一次 store 和 write 操作，让 volatile 变量的修改对其他处理器立即可见。
    **禁止指令重排序优化**

**静态变量 i 执行多线程 i\+\+ 的不安全问题**

自增语句由 4 条字节码指令构成的，依次为 getstatic、iconst\_1、iadd、putstatic，当 getstatic 把 i 的值取到操作栈顶时，volatile 保证了 i 值在此刻正确，但在执行 iconst\_1、iadd 时，其他线程可能已经改变了 i 值，操作栈顶的值就变成了过期数据，所以 putstatic 执行后就可能把较小的 i 值同步回了主内存。

**适用场景**

- 运算结果并不依赖变量的当前值。

-  一写多读，只有单一的线程修改变量值。

**内存语义**

写一个 volatile 变量时，把该线程工作内存中的值刷新到主内存。

读一个 volatile 变量时，把该线程工作内存值置为无效，从主内存读取。

**指令重排序特点**

第二个操作是 volatile 写，不管第一个操作是什么都不能重排序，确保写之前的操作不会被重排序到写之后。

第一个操作是 volatile 读，不管第二个操作是什么都不能重排序，确保读之后的操作不会被重排序到读之前。

第一个操作是 volatile 写，第二个操作是 volatile 读不能重排序。

**JSR\-133 增强 volatile 语义的原�**�

在旧的内存模型中，虽然不允许 volatile 变量间重排序，但允许 volatile 变量与普通变量重排序，可能导致内存不可见问题。JSR\-133 严格限制编译器和处理器对 volatile 变量与普通变量的重排序，确保 volatile 的写\-读和锁的释放\-获取具有相同的内存语义。

---

#### **Q8：final 可以保证可见性吗？**

final 可以保证可见性，被 final 修饰的字段在构造方法中一旦被初始化完成，并且构造方法没有把 this 引用传递出去，在其他线程中就能看见 final 字段值。

在旧的 JMM 中，一个严重缺陷是线程可能看到 final 值改变。比如一个线程看到一个 int 类型 final 值为 0，此时该值是未初始化前的零值，一段时间后该值被某线程初始化，再去读这个 final 值会发现值变为 1。

为修复该漏洞，JSR\-133 为 final 域增加重排序规则：只要对象是正确构造的（被构造对象的引用在构造方法中没有逸出），那么不需要使用同步就可以保证任意线程都能看到这个 final 域初始化后的值。

**写 final 域重排序规则**

禁止把 final 域的写重排序到构造方法之外，编译器会在 final 域的写后，构造方法的 return 前，插入一个 Store Store 屏障。确保在对象引用为任意线程可见之前，对象的 final 域已经初始化过。

**读 final 域重排序规则**

在一个线程中，初次读对象引用和初次读该对象包含的 final 域，JMM 禁止处理器重排序这两个操作。编译器在读 final 域操作的前面插入一个 Load Load 屏障，确保在读一个对象的 final 域前一定会先读包含这个 final 域的对象引用。
